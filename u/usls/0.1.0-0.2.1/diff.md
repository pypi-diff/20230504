# Comparing `tmp/usls-0.1.0-py3-none-any.whl.zip` & `tmp/usls-0.2.1-py3-none-any.whl.zip`

## zipinfo {}

```diff
@@ -1,22 +1,25 @@
-Zip file size: 60855 bytes, number of entries: 20
--rwxrwxrwx  2.0 unx      236 b- defN 23-Apr-27 09:14 usls/__init__.py
--rwxrwxrwx  2.0 unx     1879 b- defN 23-Apr-27 09:16 usls/cli.py
--rwxrwxrwx  2.0 unx    13002 b- defN 23-Apr-27 08:37 usls/run.py
--rwxrwxrwx  2.0 unx      345 b- defN 23-Apr-27 06:18 usls/src/__init__.py
--rwxrwxrwx  2.0 unx     2171 b- defN 23-Apr-27 06:18 usls/src/class_modify.py
--rwxrwxrwx  2.0 unx     1598 b- defN 23-Apr-27 06:18 usls/src/deduplicate.py
--rwxrwxrwx  2.0 unx     2537 b- defN 23-Apr-27 06:18 usls/src/dir_combine.py
--rwxrwxrwx  2.0 unx     3204 b- defN 23-Apr-27 06:18 usls/src/label_combine.py
--rwxrwxrwx  2.0 unx    18138 b- defN 23-Apr-27 06:18 usls/src/labelling_cls.py
--rwxrwxrwx  2.0 unx    41064 b- defN 23-Apr-27 08:44 usls/src/labelling_det.py
--rwxrwxrwx  2.0 unx    40829 b- defN 23-Apr-27 07:16 usls/src/labelling_det_2.py
--rwxrwxrwx  2.0 unx     3299 b- defN 23-Apr-27 06:18 usls/src/spider.py
--rwxrwxrwx  2.0 unx    24160 b- defN 23-Apr-27 09:19 usls/src/utils.py
--rwxrwxrwx  2.0 unx     9416 b- defN 23-Apr-27 08:25 usls/src/video_tools.py
--rwxrwxrwx  2.0 unx    35149 b- defN 23-Apr-27 09:19 usls-0.1.0.dist-info/LICENSE
--rwxrwxrwx  2.0 unx      588 b- defN 23-Apr-27 09:19 usls-0.1.0.dist-info/METADATA
--rwxrwxrwx  2.0 unx       92 b- defN 23-Apr-27 09:19 usls-0.1.0.dist-info/WHEEL
--rwxrwxrwx  2.0 unx       34 b- defN 23-Apr-27 09:19 usls-0.1.0.dist-info/entry_points.txt
--rwxrwxrwx  2.0 unx        5 b- defN 23-Apr-27 09:19 usls-0.1.0.dist-info/top_level.txt
-?rw-rw-r--  2.0 unx     1551 b- defN 23-Apr-27 09:19 usls-0.1.0.dist-info/RECORD
-20 files, 199297 bytes uncompressed, 58375 bytes compressed:  70.7%
+Zip file size: 60625 bytes, number of entries: 23
+-rwxrwxrwx  2.0 unx      171 b- defN 23-May-04 03:58 usls/__init__.py
+-rwxrwxrwx  2.0 unx    11563 b- defN 23-May-04 03:02 usls/cli.py
+-rwxrwxrwx  2.0 unx     2629 b- defN 23-May-04 03:02 usls/run.py
+-rwxrwxrwx  2.0 unx      309 b- defN 23-May-04 03:02 usls/src/__init__.py
+-rwxrwxrwx  2.0 unx     2171 b- defN 23-May-04 03:02 usls/src/class_modify.py
+-rwxrwxrwx  2.0 unx     6028 b- defN 23-May-04 03:02 usls/src/cleanup.py
+-rwxrwxrwx  2.0 unx     5530 b- defN 23-May-04 03:02 usls/src/deduplicate.py
+-rwxrwxrwx  2.0 unx     1739 b- defN 23-May-04 03:02 usls/src/dir_combine.py
+-rwxrwxrwx  2.0 unx     3945 b- defN 23-May-04 03:02 usls/src/info.py
+-rwxrwxrwx  2.0 unx     3204 b- defN 23-May-04 03:02 usls/src/label_combine.py
+-rwxrwxrwx  2.0 unx    18138 b- defN 23-May-04 03:02 usls/src/labelling_cls.py
+-rwxrwxrwx  2.0 unx    39435 b- defN 23-May-04 03:02 usls/src/labelling_det.py
+-rwxrwxrwx  2.0 unx    40829 b- defN 23-May-04 03:02 usls/src/labelling_det_2.py
+-rwxrwxrwx  2.0 unx     2555 b- defN 23-May-04 03:08 usls/src/rename.py
+-rwxrwxrwx  2.0 unx     3470 b- defN 23-May-04 03:02 usls/src/spider.py
+-rwxrwxrwx  2.0 unx     5906 b- defN 23-May-04 03:02 usls/src/utils.py
+-rwxrwxrwx  2.0 unx     9386 b- defN 23-May-04 03:02 usls/src/video_tools.py
+-rwxrwxrwx  2.0 unx    35149 b- defN 23-May-04 03:59 usls-0.2.1.dist-info/LICENSE
+-rwxrwxrwx  2.0 unx      540 b- defN 23-May-04 03:59 usls-0.2.1.dist-info/METADATA
+-rwxrwxrwx  2.0 unx       92 b- defN 23-May-04 03:59 usls-0.2.1.dist-info/WHEEL
+-rwxrwxrwx  2.0 unx       34 b- defN 23-May-04 03:59 usls-0.2.1.dist-info/entry_points.txt
+-rwxrwxrwx  2.0 unx        5 b- defN 23-May-04 03:59 usls-0.2.1.dist-info/top_level.txt
+?rw-rw-r--  2.0 unx     1774 b- defN 23-May-04 03:59 usls-0.2.1.dist-info/RECORD
+23 files, 194602 bytes uncompressed, 57811 bytes compressed:  70.3%
```

## zipnote {}

```diff
@@ -9,53 +9,62 @@
 
 Filename: usls/src/__init__.py
 Comment: 
 
 Filename: usls/src/class_modify.py
 Comment: 
 
+Filename: usls/src/cleanup.py
+Comment: 
+
 Filename: usls/src/deduplicate.py
 Comment: 
 
 Filename: usls/src/dir_combine.py
 Comment: 
 
+Filename: usls/src/info.py
+Comment: 
+
 Filename: usls/src/label_combine.py
 Comment: 
 
 Filename: usls/src/labelling_cls.py
 Comment: 
 
 Filename: usls/src/labelling_det.py
 Comment: 
 
 Filename: usls/src/labelling_det_2.py
 Comment: 
 
+Filename: usls/src/rename.py
+Comment: 
+
 Filename: usls/src/spider.py
 Comment: 
 
 Filename: usls/src/utils.py
 Comment: 
 
 Filename: usls/src/video_tools.py
 Comment: 
 
-Filename: usls-0.1.0.dist-info/LICENSE
+Filename: usls-0.2.1.dist-info/LICENSE
 Comment: 
 
-Filename: usls-0.1.0.dist-info/METADATA
+Filename: usls-0.2.1.dist-info/METADATA
 Comment: 
 
-Filename: usls-0.1.0.dist-info/WHEEL
+Filename: usls-0.2.1.dist-info/WHEEL
 Comment: 
 
-Filename: usls-0.1.0.dist-info/entry_points.txt
+Filename: usls-0.2.1.dist-info/entry_points.txt
 Comment: 
 
-Filename: usls-0.1.0.dist-info/top_level.txt
+Filename: usls-0.2.1.dist-info/top_level.txt
 Comment: 
 
-Filename: usls-0.1.0.dist-info/RECORD
+Filename: usls-0.2.1.dist-info/RECORD
 Comment: 
 
 Zip file comment:
```

## usls/__init__.py

```diff
@@ -1,18 +1,15 @@
 #!/usr/bin/env python
 # -*- coding:utf-8 -*- 
 
 
-__version__ = '0.1.0'
+__version__ = '0.2.1'
 
 from usls.cli import cli
 from usls.run import run
-from usls.src import resource_info
 
 
 __all__ = [
 	'__version__', 
 	'cli',
 	'run', 
-	'resource_info',
-	'gpu_info'
 ]
```

## usls/cli.py

```diff
@@ -1,92 +1,493 @@
 import sys
 import rich
 import re
 from omegaconf import OmegaConf, DictConfig
+import argparse
+from enum import Enum, auto, unique
+from rich.panel import Panel
+from typing import Dict, List, Union, Optional, Any
+
 
 from usls import __version__
+from usls.src.utils import LOGGER, CONSOLE, IMG_FORMAT, LABEL_FORMAT, VIDEO_FORMAT
 from usls.run import run
-from usls.src.utils import LOGGER, CLI_MSG_TABLE, CONSOLE
 
 
+# # support task list
+# TASKS = (
+# 	'info', 
+# 	'inspect', 'inspect2',
+# 	'dir_combine', 
+# 	'label_combine',
+# 	'spider',
+# 	'clean', 
+# 	'cleanup',
+# 	'v2is',
+# 	'vs2is',
+# 	'play',
+# 	'is2v',
+# 	'classify',
+# 	'deduplicate',
+# 	'class_modify',
+# )
+
+
+# class TasksType(Enum):
+# 	info = 0
+# 	isnepct = auto()
+# 	isnepct2 = auto()
+# 	dir_combine = auto()
+# 	label_combine = auto()
+# 	spider = auto()
+# 	clean = auto()
+# 	cleanup = auto()
+# 	v2is = auto()
+# 	vs2is = auto()
+# 	play = auto()
+# 	is2v2 = auto()
+# 	classify = auto()
+# 	deduplicate = auto()
+# 	class_modify = auto()
 
-SPECIALS = {
-	'--help': lambda: CONSOLE.print(CLI_MSG_TABLE()),
-	'-H': lambda: CONSOLE.print(CLI_MSG_TABLE()),
-	'-h': lambda: CONSOLE.print(CLI_MSG_TABLE()),
-	'--version': lambda: rich.print(f"> uselesss version: {__version__}"),
-	'-V': lambda: rich.print(f"> uselesss version: {__version__}"),
-	'-v': lambda: rich.print(f"> uselesss version: {__version__}"),
-}
-
-
-# support task list
-TASKS = (
-	'info', 
-	'inspect', 'inspect2',
-	'dir_combine', 
-	'label_combine',
-	'spider',
-	'clean', 
-	'cleanup',
-	'v2is',
-	'vs2is',
-	'play',
-	'is2v',
-	'classify',
-	'deduplicate',
-	'class_modify',
-)
 
 
 def cli() -> None:
-	args = sys.argv[1:]
 
-	if not args:
-		CONSOLE.print(CLI_MSG_TABLE())
-		return 
-
-	cmd = {'task': 'untitled'} 	# default  TODO: msg
-
-	# argv[1:]
-	for idx, x in enumerate(args):
-
-		# special cmd with `-` or `--`
-		if x.startswith('-'):
-			if x in SPECIALS.keys():
-				SPECIALS[x]()
-				return
-
-		else:	# must use '=' to specify args
-			if '=' in x:
-				try:
-					k, v = x.strip().split('=', 1)
-					if k == 'task':
-						assert v in TASKS, f"> Error: Task support: {TASKS} for now!"
-					cmd.update({k: v})
-				except Exception as E:
-					rich.print(f'{E}')
-					sys.exit(1) 
-
-			elif x.lower() in TASKS and idx == 0:
-				cmd.update({'task': x.lower()})
-			else:
-				if idx == 0:
-					rich.print(f"> Warning: `{x}` is not in supported TASKS: {TASKS}")
-				else:
-					rich.print(f"> Warning: `{x}` is not supported, ignored by deault! You can use `sth={x}`")
-
-	rich.print(f"> args: {cmd}")
-
-
-	# check if has task
-	if cmd.get('task') == 'untitled':
-		LOGGER.error(f"> `task` not specified!")
-	else:
-		conf = OmegaConf.create(cmd) 
-		run(conf) 	# run
+	if len(sys.argv) == 1:
+		sys.argv.append('-h')
+
+	args = parse_cli()
+	args.update({'task': sys.argv[1]})  # add task
+	args = OmegaConf.create(args)
+	
+	# log
+	CONSOLE.print(
+		Panel(
+			f"[green]{OmegaConf.to_yaml(args)}",
+			# f"{args}",
+			title='args',
+			box=rich.box.ROUNDED
+		)
+	)
+
+	# run
+	run(args) 	
+
+
+
+def parse_cli() -> Dict:
+
+	parser = argparse.ArgumentParser(
+		prog='usls',
+		description='😺 This is a useless toolkits for doing useless things.',
+		epilog=f'version: {__version__} '
+	)
+	parser.add_argument(
+		'--version', '-v', '-V', 
+		action='version', 
+		version=f'version: {__version__}',
+		help='get version',
+	)
+
+	subparsers = parser.add_subparsers(
+		title='Tasks',
+		description='👇 Tasks are as follows',
+		# help='task sub-commands help'
+	)
+
+	# --------------------------
+	# 	info parser ✅
+	# 	TODO: video info, img info
+	# --------------------------
+	info_parser = subparsers.add_parser(name='info', help='Directory info')
+	info_parser.add_argument(
+		'--dir', '-d',
+		required=True, type=str, default=None, 
+		help='Directory to be inspect'
+	)
+	info_parser.add_argument(
+		'--fmt',
+		required=False, type=str, nargs="+", 
+		default=IMG_FORMAT + LABEL_FORMAT + VIDEO_FORMAT, 
+		help=f'File format. default -> {IMG_FORMAT + LABEL_FORMAT + VIDEO_FORMAT}'
+	)
+	info_parser.add_argument(
+		'--non-recursive',
+		required=False, action='store_true', 
+		help="Non-recursive, do not iterable all directories"
+	)
+
+	# -----------------------------
+	# 	dir_combine parser✅
+	# -----------------------------
+	dir_combine_parser = subparsers.add_parser(
+		name='dir-combine', 
+		# aliases=['dir_combine'], 
+		help='Combine dirs with its items'
+	)
+	dir_combine_parser.add_argument(
+		'--input-dir', '--dir', '-d',
+		required=True, type=str, default=None, help='Directory to be combined'
+	)
+	dir_combine_parser.add_argument(
+		'--output-dir', '--out',
+		required=False, type=str, default='output-conbined', help='Directory saveout'
+	)
+	dir_combine_parser.add_argument(
+		'--fmt',
+		required=False, nargs='+', type=str, default=[], 
+		help="File format like: .py, .jpg, .txt, .yaml, ..."
+	)
+	dir_combine_parser.add_argument(
+		'--move',
+		required=False, action='store_true', 
+		help='copy or move, default is copy.'
+	)
+
+
+	# ---------------------
+	# 	cleanup parser  ✅
+	# ---------------------
+	cleanup_parser = subparsers.add_parser(
+		name='clean', aliases=['cleanup'], 
+		help='Clean-Up of Images & Labels'
+	)
+	cleanup_parser.add_argument(
+		'--img-dir', 
+		required=True, type=str, default=None, 
+		help='image dir'
+	)
+	cleanup_parser.add_argument(
+		'--label-dir',
+		required=False, type=str, default=None, 
+		help='label dir'
+	)
+	cleanup_parser.add_argument(
+		'--fmt-img',
+		required=False, type=str, default=IMG_FORMAT, 
+		help=f'image format: {IMG_FORMAT}'
+	)	
+	cleanup_parser.add_argument(
+		'--fmt-label',
+		required=False, type=str, default=LABEL_FORMAT, 
+		help=f'label format: {LABEL_FORMAT}'
+	)
+	cleanup_parser.add_argument(
+		'--filtered-dir',
+		required=False, type=str, default='cleanup-filtered', help='filtered dir'
+	)	
+	cleanup_parser.add_argument(
+		'--keep-empty-label',
+		action='store_true', 
+		help='keep empty label file or not'
+	)
+	cleanup_parser.add_argument(
+		'--non-recursive',
+		required=False, action='store_true', 
+		help="Do not iterable all directories"
+	)
+
+
+	# ---------------------
+	# 	spider parser  ✅
+	# ---------------------
+	spider_parser = subparsers.add_parser(
+		name='spider', 
+		help='Baidu Image Spider'
+	)
+	spider_parser.add_argument(
+		'--words', 
+		default='', nargs="+", required=True, type=str, 
+		help='Key words'
+	)
+	spider_parser.add_argument(
+		'--output-dir',
+		required=False, type=str, default='baidu-image-spider', help='baidu image spider output dir'
+	)	
+
+	# ---------------------
+	# 	rename parser  ✅
+	# ---------------------
+	rename_parser = subparsers.add_parser(
+		name='rename', 
+		help='Rename directory items'
+	)
+	rename_parser.add_argument(
+		'--dir', '-d',
+		required=True, type=str, default=None, 
+		help='Directory to be inspect'
+	)
+
+	rename_group = rename_parser.add_mutually_exclusive_group(
+		required=True
+	)
+	rename_group.add_argument(
+		'--zero-number', '--znum',
+		action='store_true',
+		required=False,
+		help='number ordered, left padding with N zeros'
+	)
+	rename_group.add_argument(
+		'--number', '--num',
+		action='store_true',
+		required=False,
+		help='number ordered'
+	)
+	rename_group.add_argument(
+		'--random', 
+		action='store_true',
+		required=False,
+		help='random raname'
+	)
+	rename_group.add_argument(
+		'--uuid', '--uuid4', 
+		action='store_true',
+		required=False,
+		help='random raname'
+	)
+	rename_group.add_argument(
+		'--prefix',
+		required=False, type=str, default=None, 
+		help='prefix-original'
+	)
+
+
+	# --------------------------
+	# 	de-duplicator parser  ✅
+	# --------------------------
+	de_duplicate_parser = subparsers.add_parser(
+		name='de-duplicate', aliases=['check'], 
+		help='Check image integrity and de-duplicate images'
+	)
+	de_duplicate_parser.add_argument(
+		'--dir', '-d', '--input-dir',
+		required=True, type=str, default=None, 
+		help='Images Directory'
+	)
+	de_duplicate_parser.add_argument(
+		'--duplicated-dir',
+		required=False, type=str, default='duplicated-items', 
+		help='Duplicated Items Directory'
+	)
+	de_duplicate_parser.add_argument(
+		'--deprecated-dir',
+		required=False, type=str, default='deprecated-items', 
+		help='Depracted Items Directory'
+	)
+	de_duplicate_parser.add_argument(
+		'--distance', '--dist',
+		required=False, type=int, default=3, 
+		help='Based on similarity, need a distance parameter, and cost more time'
+	)
+	de_duplicate_group = de_duplicate_parser.add_mutually_exclusive_group(
+		required=True
+	)
+	de_duplicate_group.add_argument(
+		'--simple',
+		action='store_true',
+		required=False,
+		help='Simple but more accurately'
+	)
+	de_duplicate_group.add_argument(
+		'--similarity', '--hash',
+		action='store_true',
+		required=False, 
+		help='Based on similarity, need a distance parameter, and cost more time'
+	)
+
+
+	# ---------------------
+	# 	v2is parser   ✅
+	# ---------------------
+	v2is_parser = subparsers.add_parser(
+		name='v2is', 
+		help='Single video to images'
+	)
+	v2is_parser.add_argument(
+		'--source', '--video', '-v',
+		required=True, type=str, default=None, 
+		help='Video source input'
+	)
+	v2is_parser.add_argument(
+		'--output-dir',
+		required=False, type=str, default='v2is', 
+		help='Saveout Directory'
+	)	
+	v2is_parser.add_argument(
+		'--frame', '--interval',
+		required=False, type=int, default=10, 
+		help='Frame interval'
+	)	
+	v2is_parser.add_argument(
+		'--fmt-img',
+		required=False, type=str, default='.jpg', 
+		help='Image clipped format'
+	)		
+	v2is_parser.add_argument(
+		'--view',
+		action='store_true',
+		required=False, 
+		help='View when clipping'
+	)
+	v2is_parser.add_argument(
+		'--flip',
+		required=False, type=str, default=None,
+		choices=['ud', 'lr', 'udlr', 'lrud'],
+		help='Flipping video'
+	)
+	v2is_parser.add_argument(
+		'--rotate',
+		required=False, type=int, default=None,
+		choices=[90, 180, 270],
+		help='Counterwise Rotation'
+	)
+
+	# ---------------------
+	# 	vs2is parser   ✅
+	# ---------------------
+	vs2is_parser = subparsers.add_parser(
+		name='vs2is', 
+		help='Videos to images'
+	)
+	vs2is_parser.add_argument(
+		'--dir', '--source', '--video', '-v',
+		required=True, type=str, default=None, 
+		help='Video source input'
+	)
+	vs2is_parser.add_argument(
+		'--output-dir',
+		required=False, type=str, default='vs2is', 
+		help='Saveout Directory'
+	)	
+	vs2is_parser.add_argument(
+		'--frame', '--interval',
+		required=False, type=int, default=10, 
+		help='Frame interval'
+	)	
+	vs2is_parser.add_argument(
+		'--fmt-img',
+		required=False, type=str, default='.jpg', 
+		help='Image clipped format'
+	)		
+	vs2is_parser.add_argument(
+		'--view',
+		action='store_true',
+		required=False, 
+		help='View when clipping'
+	)
+	vs2is_parser.add_argument(
+		'--flip',
+		required=False, type=str, default=None,
+		choices=['ud', 'lr', 'udlr', 'lrud'],
+		help='Flipping video'
+	)
+	vs2is_parser.add_argument(
+		'--rotate',
+		required=False, type=int, default=None,
+		choices=[90, 180, 270],
+		help='Counterwise Rotation'
+	)
+
+	# ---------------------------------
+	# 	video play & record parser   ✅
+	# ---------------------------------
+	play_rec_parser = subparsers.add_parser(
+		name='play', 
+		help='Play and record single video or stream.'
+	)
+	play_rec_parser.add_argument(
+		'--source', '--video', '-v',
+		required=True, type=str, default=None, 
+		help='Video source input'
+	)
+	play_rec_parser.add_argument(
+		'--output-dir',
+		required=False, type=str, default='video-records', 
+		help='Saveout Directory'
+	)	
+	play_rec_parser.add_argument(
+		'--delay',
+		required=False, type=int, default=1, 
+		help='Keywait'
+	)	
+	play_rec_parser.add_argument(
+		'--fourcc',
+		required=False, type=str, default='mp4v', 
+		help='Image clipped format'
+	)		
+	play_rec_parser.add_argument(
+		'--no-view',
+		action='store_true',
+		required=False, 
+		help='Do not view while playing'
+	)
+	play_rec_parser.add_argument(
+		'--rec',
+		action='store_true',
+		required=False, 
+		help='Record at the start'
+	)
+	play_rec_parser.add_argument(
+		'--flip',
+		required=False, type=str, default=None,
+		choices=['ud', 'lr', 'udlr', 'lrud'],
+		help='Flipping video'
+	)
+	play_rec_parser.add_argument(
+		'--rotate',
+		required=False, type=int, default=None,
+		choices=[90, 180, 270],
+		help='Counterwise Rotation'
+	)
+
+
+	# ---------------------
+	# 	download parser  
+	# ---------------------
+
+
+
+	# ----------------------------
+	# 	label-combine parser  
+	# ----------------------------
+
+
+	# ---------------------
+	# 	class-modify parser  
+	# ---------------------
+
+
+
+	# ---------------------
+	# 	inspect parser  ✅
+	# 	TODO: update 
+	# ---------------------
+	inspect_parser = subparsers.add_parser(
+		name='inspect', # aliases=['label-det'], 
+		help='Detection labelling'
+	)
+	inspect_parser.add_argument(
+		'--img-dir', '--dir',
+		required=True, type=str, default=None, help='image dir'
+	)
+	inspect_parser.add_argument(
+		'--label-dir',
+		required=False, type=str, default=None, help='label dir'
+	)
+	inspect_parser.add_argument(
+		'--depreacated-dir', 
+		required=False, type=str, default="deprecated-images", help='deprecated image dir'
+	)
+	inspect_parser.add_argument('--classes', default='', nargs="+", required=True, type=str, help='label classes list')
+	inspect_parser.add_argument('--window-width', default=800, type=int, help='opencv windows width')
+	inspect_parser.add_argument('--window-height', default=600, type=int, help='opencv windows height')
+
+
+	args = vars(parser.parse_args())
+	return args
 
 
 
 
 if __name__ == '__main__':
 	cli()
```

### encoding

```diff
@@ -1 +1 @@
-us-ascii
+utf-8
```

## usls/run.py

```diff
@@ -8,391 +8,86 @@
 import sys
 import random
 import time
 from omegaconf import OmegaConf, DictConfig
 
 # ---------------------------------------------------------------------------------------------
 from usls.src.utils import (
-    get_corresponding_label_path, Colors, load_from_dir,
-    img_label_dir_cleanup, get_img_path, LOGGER, IMG_FORMAT, VIDEO_FORMAT,
-    is_point_in_rect, CONSOLE
+    Colors, LOGGER, IMG_FORMAT, VIDEO_FORMAT, CONSOLE
 )
-from usls.src.labelling_det import inspect
-from usls.src.labelling_det_2 import inspect2
-from usls.src.labelling_cls import classify
-from usls.src.video_tools import play_and_record, video_to_images, videos_to_images, images_to_video
-from usls.src.spider import spider_img_baidu
-from usls.src.dir_combine import dir_combine
+
+from usls.src.info import run_dir_info
+from usls.src.labelling_det import run_inspect
+from usls.src.cleanup import run_cleanup
+from usls.src.dir_combine import run_dir_combine
+from usls.src.spider import run_spider
+from usls.src.rename import run_rename
+from usls.src.deduplicate import run_deduplicate
+from usls.src.video_tools import run_v2is, run_vs2is, run_play 
+
+
+# TODO
+# from usls.src.labelling_det_2 import inspect2
+# from usls.src.labelling_cls import classify
 from usls.src.label_combine import combine_labels
-from usls.src.deduplicate import deduplicate
 from usls.src.class_modify import class_modify
 # ---------------------------------------------------------------------------------------------
 
 
 
 
 
-
 def run(opt: DictConfig):
 
+    task_mapping = {
+        'info': run_dir_info,
+        'dir_combine': run_dir_combine,
+        'dir-combine': run_dir_combine,
+        'inspect': run_inspect,
+        'clean': run_cleanup,
+        'cleanup': run_cleanup,
+        'clean-up': run_cleanup,
+        'spider': run_spider,
+        'rename': run_rename,
+        'de-duplicate': run_deduplicate,
+        'de_duplicate': run_deduplicate,
+        'check': run_deduplicate,
+        'v2is': run_v2is,
+        'vs2is': run_vs2is,
+        'play': run_play,
+
+
+    }.get(opt.task)(opt)
+
+
+
+    exit()
+
+    # # TODO
+    # # -------------------------------------
+    # #   label combine
+    # # -------------------------------------
+    # if opt.task == 'label_combine':
+
+    #     assert opt.get('input_dir'), f"No `input_dir=???` args when task is `label_combine`! default: `output_dir=output-label-combine`"
+    #     input_dir = opt.input_dir
+    #     output_dir = opt.output_dir if opt.get('output_dir') else 'output-label-combine'
+
+    #     combine_labels(input_dir=input_dir, output_dir=output_dir)
+
+
 
-    # -------------------------------------
-    #   img & label dir info 
-    # -------------------------------------
-    if opt.task == 'info':
-
-        with CONSOLE.status("[bold green]Working on info checking...") as status:
-            _, _, _, = load_from_dir(
-                img_dir=opt.get('img_dir'), 
-                label_dir=opt.get('label_dir'), 
-                video_dir=opt.get('video_dir'), 
-                # verbose=True,
-                # title='INFO',
-                caption='INFO\n',
-            )
-
-
-    # -------------------------------------
-    #   inspect 
-    # -------------------------------------
-    if opt.task in ('inspect', 'classify'):
-
-        img_dir = opt.get('img_dir')
-        label_dir = opt.label_dir if opt.get('label_dir') else img_dir
-
-        assert all((img_dir, label_dir)), f"Not `img_dir=???` or `label_dir=???` input!"
-        assert Path(img_dir).is_dir() and Path(label_dir).is_dir(), f"`img_dir={img_dir}` or `label_dir={label_dir}` is not a dir path"
-
-        mv_dir = opt.mv_dir if opt.get('mv_dir') else 'moved_dir'  # save moved dir
-        wrong_img_dir = opt.wrong_img_dir if opt.get('wrong_img_dir') else 'wrong_img_dir'  # wrong dir
-
-        assert opt.get('classes'), f"No `classes=???` args when task is `inspect`!"
-        classes = opt.classes.split(',')
-        window_width = opt.window_width if opt.get('window_width') else 800  # save moved dir
-        window_height = opt.window_height if opt.get('window_height') else 600  # save moved dir
-
-        # det
-        if opt.task == 'inspect':
-            inspect( 
-                img_dir, 
-                label_dir,
-                mv_dir,
-                wrong_img_dir,
-                classes,
-                window_width,
-                window_height,
-            )
-
-        # cls
-        if opt.task == 'classify':
-            classify( 
-                img_dir, 
-                label_dir,
-                mv_dir,
-                wrong_img_dir,
-                classes,
-                window_width,
-                window_height,
-            )
-
-
-    # -------------------------------------
-    #   inspect 2
-    # -------------------------------------
-    if opt.task in ('inspect2'):
-
-        with CONSOLE.status("[bold cyan]Doing inspect...") as status:
-
-
-            img_dir = opt.get('img_dir')
-            label_dir = opt.label_dir if opt.get('label_dir') else img_dir
-
-            assert all((img_dir, label_dir)), f"Not `img_dir=???` or `label_dir=???` input!"
-            assert Path(img_dir).is_dir() and Path(label_dir).is_dir(), f"`img_dir={img_dir}` or `label_dir={label_dir}` is not a dir path"
-
-            mv_dir = opt.mv_dir if opt.get('mv_dir') else 'moved_dir'  # save moved dir
-            wrong_img_dir = opt.wrong_img_dir if opt.get('wrong_img_dir') else 'wrong_img_dir'  # wrong dir
-
-
-            assert opt.get('classes'), f"No `classes=???` args when task is `inspect`!"
-            classes = opt.classes.split(',')
-            window_width = opt.window_width if opt.get('window_width') else 800  # save moved dir
-            window_height = opt.window_height if opt.get('window_height') else 600  # save moved dir
-
-            # det
-            if opt.task == 'inspect2':
-
-                inspect2( 
-                    img_dir, 
-                    label_dir,
-                    mv_dir,
-                    wrong_img_dir,
-                    classes,
-                    window_width,
-                    window_height,
-                )
-
-
-
-    # -------------------------------------
-    #   img & label dir clean up 
-    # -------------------------------------
-    if opt.task in ('clean', 'cleanup'):
-
-        img_dir = opt.get('img_dir')
-        label_dir = opt.label_dir if opt.get('label_dir') else img_dir
-
-        assert img_dir, f"No `img_dir=???` input!"
-        assert label_dir, f"No `label_dir=???` input!"
-        assert Path(img_dir).is_dir() and Path(label_dir).is_dir(), f"`img_dir={img_dir}` or `label_dir={label_dir}` is not a dir path"
-
-        mv_dir = opt.mv_dir if opt.get('mv_dir') else 'moved_dir'  # save moved dir
-
-        if opt.get('clean_empty'):  
-            if opt.clean_empty.lower() == 'false':
-                clean_empty = True
-            else:
-                clean_empty = False
-        else:
-            clean_empty = False
-
-
-            # display
-            table = rich.table.Table(
-                # title='usls cleanup', 
-                # title_style='bold cyan',
-                box=rich.box.ASCII2, 
-                show_lines=False, 
-                caption=f"Cleanup\n",
-                caption_justify='center',
-                header_style='bold',
-                caption_style='bold cyan',
-            )
-            table.add_column(
-                "Directory", 
-                justify="left", 
-                style="b", 
-                no_wrap=False
-            )
-            table.add_column(
-                "Absolute Path", 
-                justify="left", 
-                style="b green", 
-                no_wrap=False
-            )
-            table.add_row(f"IMAGE", f"{Path(img_dir).resolve()}", end_section=False)
-            table.add_row(f"LABEL", f"{Path(label_dir).resolve()}", end_section=False)
-            CONSOLE.print(table)
-
-
-        # in case of other keys input
-        while True: 
-            user_answer = CONSOLE.input("Are you sure to do [b cyan]clean-up[/b cyan] :smiley: ? > ")
-            if user_answer.lower() in ('n', 'no', 'false', 'f'):
-                sys.exit("Cancelled cleanup!")
-
-            elif user_answer.lower() in ('y', 'yes', 'true', 't'):
-                # with CONSOLE.status("[bold cyan]Doing cleanup...") as status:
-                img_label_dir_cleanup(
-                    img_dir,
-                    label_dir,
-                    mv_dir,
-                    IMG_FORMAT, 
-                    info=True, 
-                    dont_clean_empty_txt=clean_empty  # false default
-                )
-
-                break
-
-
-
-    # -------------------------------------
-    #   label combine
-    # -------------------------------------
-    if opt.task == 'label_combine':
-
-        assert opt.get('input_dir'), f"No `input_dir=???` args when task is `label_combine`! default: `output_dir=output-label-combine`"
-        input_dir = opt.input_dir
-        output_dir = opt.output_dir if opt.get('output_dir') else 'output-label-combine'
-
-        combine_labels(input_dir=input_dir, output_dir=output_dir)
-
-
-    # -------------------------------------
-    #   dir combine
-    # -------------------------------------
-    if opt.task == 'dir_combine':
-        assert opt.get('input_dir'), f"No `input_dir=???` args when task is `label_combine`! default: `output_dir=output-label-combine`"
-        input_dir = opt.input_dir
-        output_dir = opt.output_dir if opt.get('output_dir') else 'output-dir-combine'
-
-        if opt.get('suffix'):
-            suffix = opt.suffix.split(',')
-        else:
-            suffix = []
-
-        if opt.get('move'):
-            if opt.move.lower() == 'true':
-                move = True
-            else:
-                move = False
-        else:
-            move = False
-
-
-        with CONSOLE.status("[bold cyan]Combining directories...") as status:
-
-            dir_combine(
-                input=input_dir,
-                output=output_dir,
-                suffix=suffix,
-                move=move
-            )
-
-
-    # -------------------------------------
-    #  video_tools => video to images 
-    # -------------------------------------
-    if opt.task in ('v2is', 'vs2is'):
-
-        frame = float(opt.frame) if opt.get('frame') else 20
-
-        # view
-        if opt.get('view'):
-            if opt.view.lower() == 'true':
-                view = True
-            else:
-                view = False
-        else:
-            view = False
-
-        # flip
-        if opt.get('flip'):
-            if opt.flip.lower() == 'true':
-                flip = True
-            else:
-                flip = False
-        else:
-            flip = False
-
-        # fmt_img
-        fmt_img = opt.fmt_img if opt.get('fmt_img') else '.jpg' 
-
-        if opt.task == 'v2is':
-            assert opt.get('source'), f"No `source=???` args when task is `v2is`!"
-            source = opt.source
-            output_dir = opt.output_dir if opt.get('output_dir') else 'v2is'
-
-            with CONSOLE.status("[bold cyan]video->images, spliting...\n") as status:
-                video_to_images(
-                    source=source,      
-                    output=output_dir,      
-                    x=frame,
-                    view=view,
-                    flip=flip,
-                    img_fmt=fmt_img
-                )
-        elif opt.task == 'vs2is':
-            assert opt.get('input_dir'), f"No `input_dir=???` args when task is `vs2is`!"
-            input_dir = opt.input_dir
-            output_dir = opt.output_dir if opt.get('output_dir') else 'vs2is'
-
-
-            videos_to_images(
-                input_dir=input_dir,
-                output_dir=output_dir,
-                x=frame,
-                view=view,
-                flip=flip,
-                img_fmt=fmt_img
-            )
-
-
-
-    # -------------------------------------
-    #   video_tools => play and rec 
-    # -------------------------------------
-    if opt.task == 'play':
-        assert opt.get('source'), f"No `source=???` args when task is `play`!"
-        source = opt.source
-
-        delay = int(opt.delay) if opt.get('delay') else 1
-        # flip
-        if opt.get('flip'):
-            if opt.flip.lower() == 'true':
-                flip = True
-            else:
-                flip = False
-        else:
-            flip = False
-
-        # with CONSOLE.status("[bold cyan]Playing...\n") as status:
-        play_and_record(
-            source=source, 
-            delay=delay, 
-            flip=flip
-        )
-
-
-    # -------------------------------------
-    # video_tools => images to video
-    # -------------------------------------
-    if opt.task == 'is2v':
-        assert opt.get('input_dir'), f"No `input_dir=???` args when task is `is2v`!"
-        input_dir = opt.input_dir
-        fps = int(opt.fps) if opt.get('fps') else 30
-        last4 = int(opt.last4) if opt.get('last4') else 60
-
-        if opt.get('video_size'):
-            if ',' in opt.video_size:
-                video_size = list(map(int, opt.video_size.split(',')))
-            else:
-                video_size = (int(opt.video_size), int(opt.video_size))
-
-        else:
-            video_size = (640, 640)
-
-        images_to_video(
-            source=input_dir, 
-            last4=last4, 
-            fps=fps, 
-            size=video_size,
-        )
-
-
-    # -------------------------------------
-    #   spider image from baidu
-    # -------------------------------------
-    if opt.task == 'spider':
-        assert opt.get('words'), f"No `words=???` args when task is `spider`!"
-        words = opt.words.split(',')
-        spider_img_baidu(words)
-
-    # -------------------------------------
-    #   de-duplicate
-    # -------------------------------------
-    if opt.task == 'deduplicate':
-        assert opt.get('input_dir'), f"No `input_dir=???` args when task is `deduplicate`!"
-        input_dir = opt.input_dir
-        mv_dir = opt.mv_dir if opt.get('mv_dir') else 'move_deduplicate_dir'
-
-        deduplicate(
-            input_dir=input_dir, 
-            move_dir=mv_dir, 
-            info=False
-        )
-
-    # -------------------------------------
-    #   class modify
-    # -------------------------------------
-    if opt.task == 'class_modify':
-        assert opt.get('input_dir'), f"No `input_dir=???` args when task is `class_modify`!"
-        input_dir = opt.input_dir
+    # # -------------------------------------
+    # #   class modify
+    # # -------------------------------------
+    # if opt.task == 'class_modify':
+    #     assert opt.get('input_dir'), f"No `input_dir=???` args when task is `class_modify`!"
+    #     input_dir = opt.input_dir
         
-        assert opt.get('to'), f"No `to=???` args when task is `class_modify`!"
-        to = opt.to
+    #     assert opt.get('to'), f"No `to=???` args when task is `class_modify`!"
+    #     to = opt.to
 
-        class_modify(
-            input_dir=input_dir, 
-            to=to
-        )
+    #     class_modify(
+    #         input_dir=input_dir, 
+    #         to=to
+    #     )
```

## usls/src/__init__.py

```diff
@@ -1,13 +1,14 @@
-
-
-
 from .utils import *
-from .labelling_det import inspect
-from .labelling_cls import classify
-from .video_tools import play_and_record, video_to_images, videos_to_images, images_to_video
-from .spider import spider_img_baidu
-from .dir_combine import dir_combine
-from .label_combine import combine_labels
-from .class_modify import class_modify
+from .rename import *
+from .info import *
+from .cleanup import *
+from .deduplicate import *
+from .labelling_det import *
+from .labelling_cls import *
+from .video_tools import * 
+from .spider import * 
+from .dir_combine import *
+from .label_combine import * 
+from .class_modify import *
```

## usls/src/deduplicate.py

```diff
@@ -1,55 +1,167 @@
-import hashlib
 import os
 from pathlib import Path
 import time
 import shutil
 import cv2
 from PIL import Image
 from tqdm import tqdm
 import rich
-
-
-from.utils import IMG_FORMAT
-
-
-def get_md5(img_path):
-    m = hashlib.md5(open(img_path,'rb').read())
-    return m.hexdigest()
-
-
-def deduplicate(input_dir, move_dir= "deduplicate-dir", info=False):
-    image_list = [x for x in Path(input_dir).iterdir() if x.suffix.lower() in IMG_FORMAT]
-    rich.print(f"> Now only support: {IMG_FORMAT}\n> Has {len(image_list)} images before deduplicating!")
-
-    img_md5_dict = {} # {md5: abs_img_path}
-
-    if not Path(move_dir).exists():
-        Path(move_dir).mkdir(exist_ok=True, parents=True)
-
-    # t1 = time.time()
-    for img in tqdm(image_list, 'De-duplicating...'):
-
-        if cv2.imread(str(img.resolve())) is not None:
-            md5 = get_md5(str(img.resolve()))
-
-            if md5 in img_md5_dict.keys():
-                similar_img_path = img_md5_dict[md5]
-                shutil.move(str(img.resolve()), str(Path(move_dir).resolve()))
-                if info:
-                    rich.print(f"Move [{img} to {Path(move_dir)}] | similar image is [{similar_img_path}]")
-            else:
-                img_md5_dict[md5] = str(Path(img))
-
-        else:
-            shutil.move(str(img.resolve()), str(Path(move_dir).resolve()))
-            if info:
-                rich.print(f"Wrong image! Move [{img} to {Path(move_dir)}]")
-
-
-
-    rich.print(f"> Now has {len([x for x in Path(input_dir).iterdir() if x.suffix in ('.png', '.jpg', '.jpeg')])} images.")
-
-
-
-if __name__=='__main__':
-    deduplicate()
+from omegaconf import OmegaConf, DictConfig
+from typing import Dict, List
+from PIL import Image, ImageOps
+import photohash
+
+from usls.src.utils import (
+    CONSOLE, IMG_FORMAT, VIDEO_FORMAT, LABEL_FORMAT, 
+    increment_path, get_md5, verify_images, time_now
+)
+    
+
+
+def deduplicate(
+        directory, 
+        directory_duplicated, 
+        directory_deprecated, 
+        simple=False,
+        similarity=False,
+        distance=3,
+    ):
+
+
+    # get files
+    f_list = [x for x in Path(directory).iterdir() if x.suffix.lower() in IMG_FORMAT]
+    CONSOLE.log(f"Find {len(f_list)} files (image file only: {IMG_FORMAT}).")
+
+
+    # saveout directory: increment
+    directory_duplicated = increment_path(Path(directory_duplicated), exist_ok=False, sep='-')  # duplicated
+    directory_duplicated.mkdir(parents=True, exist_ok=True)  # make dir
+    directory_deprecated = increment_path(Path(directory_deprecated), exist_ok=False, sep='-')  # deprecated
+    directory_deprecated.mkdir(parents=True, exist_ok=True)  # make dir
+
+
+    # way 1
+    if simple:
+        with CONSOLE.status("[bold green]Checking integrity & De-duplicating...") as status:
+
+            md5_img_dict = {}   # {md5: img_path}
+            for p in f_list:  # loop
+                if verify_images(path=p, output_dir=directory_deprecated):
+                    md5 = get_md5(str(p))
+
+                    # compare and save 
+                    if md5 in md5_img_dict.keys():
+                        similar_img_path = md5_img_dict[md5]
+                        shutil.move(str(p), str(directory_duplicated))
+                    else:
+                        md5_img_dict[md5] = p
+
+
+        # conclude
+        f_left_list = [x for x in Path(directory).iterdir() if x.suffix.lower() in IMG_FORMAT]
+        f_duplicated_list = [x for x in Path(directory_duplicated).iterdir() if x.suffix.lower() in IMG_FORMAT]
+        f_deprecatde_list = [x for x in Path(directory_deprecated).iterdir() if x.suffix.lower() in IMG_FORMAT]
+
+
+
+    # way 2
+    if similarity:
+
+        # remove deprecated images
+        with CONSOLE.status("[bold green]Checking integrity...") as status:
+            for p in f_list:
+                verify_images(path=p, output_dir=directory_deprecated)
+
+        # De-duplicating almost O(n^2)
+        with CONSOLE.status("[bold green]De-duplicating base on similarity (it will cost much time)...") as status:
+            f_left_list = [x for x in Path(directory).iterdir() if x.suffix.lower() in IMG_FORMAT]
+
+            f_save = list()
+            f_duplicated_list = list()
+
+            # loop
+            while len(f_left_list) > 0:
+                f_save.append(f_left_list.pop(0))  # pop 1st
+
+                # get similarity list
+                is_similar_list = []
+                for p in f_left_list:
+                    is_similar_list.append(photohash.is_look_alike(f_save[-1], p, tolerance=distance))
+
+                # update
+                duplicate_items = [x for x, y in zip(f_left_list, is_similar_list) if y]  # duplicates
+                f_duplicated_list.extend(duplicate_items)
+                [f_left_list.remove(x) for x in duplicate_items]
+
+
+            # conclude
+            f_left_list = f_save
+            f_deprecatde_list = [x for x in Path(directory_deprecated).iterdir() if x.suffix.lower() in IMG_FORMAT]
+
+
+            # remove duplicated files
+            for f in f_duplicated_list:
+                shutil.move(str(f), str(directory_duplicated))
+
+
+
+    # clean up dirs
+    if len(f_duplicated_list) == 0:
+        directory_duplicated.rmdir()  # rmdir
+    if len(f_deprecatde_list) == 0:
+        directory_deprecated.rmdir()  # rmdir
+
+    # log
+    if len(f_list) == len(f_left_list):
+        CONSOLE.log(f"😃 Nothing changed! All images are perfectly unique and well integrated!")
+    else:
+        CONSOLE.log(f"Task complete ✅")
+
+
+    # display
+    table = rich.table.Table(
+        title='\n', 
+        title_style='left',
+        box=rich.box.ASCII,   # box.MARKDOWN ,SIMPLE   , rich.box.ASCII2
+        show_lines=False, 
+        show_header=True,
+        caption=f"{time_now()}\n",
+        caption_justify='center',
+        header_style='',
+        show_footer=False,
+    )
+
+    table.add_column(header="Type", justify="left", no_wrap=False)
+    table.add_column(header="Num", justify="left", no_wrap=False)
+    table.add_column(header="Path", justify="left", no_wrap=False)
+
+
+    table.add_row(f"Original", f"{len(f_list)}", f"{Path(directory).resolve()}", end_section=False)
+    table.add_row(f"Left", f"{len(f_left_list)}", f"{Path(directory).resolve()}", end_section=False)
+    table.add_row(
+        f"Duplicated", 
+        f"{len(f_duplicated_list)}", 
+        f"{directory_duplicated.resolve() if len(f_duplicated_list) > 0 else '---'}", 
+        end_section=False
+    )
+    table.add_row(
+        f"Deprecated", 
+        f"{len(f_deprecatde_list)}", 
+        f"{directory_deprecated.resolve() if len(f_deprecatde_list) > 0 else '---'}",
+        end_section=False
+    )
+    CONSOLE.print(table)
+
+
+
+
+def run_deduplicate(args: DictConfig):
+    # with CONSOLE.status("[bold green]Checking & De-duplicating...") as status:
+    deduplicate(
+        directory=args.dir, 
+        directory_duplicated=args.duplicated_dir, 
+        directory_deprecated=args.deprecated_dir, 
+        simple=args.simple,
+        similarity=args.similarity,
+        distance=args.distance,
+    )
```

### encoding

```diff
@@ -1 +1 @@
-us-ascii
+utf-8
```

## usls/src/dir_combine.py

```diff
@@ -1,97 +1,86 @@
-#!/usr/bin/env python
-# -*- coding:utf-8 -*- 
 
 from tqdm import tqdm 
 from pathlib import Path
-import argparse
 import sys
 import rich
 import os
 import shutil
 
+from omegaconf import OmegaConf, DictConfig
+from usls.src.utils import CONSOLE, IMG_FORMAT, VIDEO_FORMAT, LABEL_FORMAT, get_common_files
 
-#--------------------------------------------
-#       PYTHON_PATH
-#--------------------------------------------
-FILE = Path(__file__).resolve()
-ROOT = FILE.parents[1]  # YOLOv5 root directory
-if str(ROOT) not in sys.path:
-    sys.path.append(str(ROOT))  # add ROOT to PATH
-ROOT = Path(os.path.relpath(ROOT, Path.cwd()))  # abs path => relative
-# rich.print(list(FILE.parents))
-# rich.print(f"[italic magenta]==>Current Python PATH: {ROOT}")
-#--------------------------------------------
 
 
+def dir_combine(
+		input_dir,
+		output_dir,
+		fmt=[],  #
+		move=False,
+	):
 
-def parse_opt():
-    parser = argparse.ArgumentParser()
-    parser.add_argument('--input', type=str, default='./', help='img dir path(s)')
-    parser.add_argument('--output', type=str, default='raw_video/img_combined', help='output dir')
-    parser.add_argument('--suffix', nargs='+', type=str, default=[], help=".py', '.jpg', '.txt")
-    parser.add_argument('--move', action='store_true', help='copy or move')
-
-    opt = parser.parse_args()
-    rich.print(opt, end="\n\n")
-    return opt
+	
+	# check if input_dir is dir
+	if not Path(input_dir).is_dir():
+		raise TypeError(f"{input_dir} is not a dreectory.")
 
 
-
-def dir_combine(input,
-				output,
-				# multi=False,
-				suffix=[],  # 
-				move=False,
-				):
-
-
-	saveout_dir = Path(output).resolve()
+	saveout_dir = Path(output_dir).resolve()
 
 	# mkdir if now exists OR check if has data in exist dir
 	if not saveout_dir.exists():
-		rich.print("> Output dir is not exist! Create automaticlly.", end="\n")
 		saveout_dir.mkdir()
 	else:
-		rich.print(f"> Output dir: [u]{saveout_dir}[/u] is exist!", end="\t")
-		size = len([x for x in saveout_dir.iterdir()])
-		if size > 1:
-			rich.print("[bold red]And it has content, Break! Please check!")
-			sys.exit(-1)
-			# raise StopIteration
-		else:
-			rich.print("[green]No content in it. Don't worry about it")
+		_size = len([x for x in saveout_dir.iterdir()])
+		if _size > 1:
+			CONSOLE.log(
+				f"[u green]{saveout_dir}[/u green] [b red]exists[/b red]! And has {_size} items!\n"
+				f"[b red]Try somewhere else.\n"
+				)
+			sys.exit()
 		
 
 	# glob
-	item_list = []
-
-	if len(suffix) == 0:
-		item_list += [x for x in Path(input).glob("**/*") if x.is_file()]
-
+	if len(fmt) == 0:
+		item_list = [x for x in Path(input_dir).glob("**/*") if x.is_file()]
 	else:
-		for s in suffix:
+		item_list = []
+		for s in fmt:
 			s = "**/*" + s
-			item_list += [x for x in Path(input).glob(s)]
+			item_list += [x for x in Path(input_dir).glob(s)]
 
-	# rich.print(f"[italic blue]==>Dir to be combined:[/italic blue]\n{item_list}\n\n")
-
-
-	# all dirs to be combined
-	for d in tqdm(item_list, '> Processing...'):
-
-		# s = str(d).replace('/', '_')
-		s = str(d).replace(os.path.sep, '_')
-		des_path = saveout_dir.resolve() / s 
-		if move:
-			shutil.move(str(d.resolve()), str(des_path))
-		else:
-			shutil.copy(str(d.resolve()), str(des_path))
 
+	# combining
+	if len(item_list) == 0:
+		# raise ValueError(f'No items found to be combined!')
+		CONSOLE.log(
+			f'[red]Not Found!\n'
+			f'[red]Go checking the directory and fmt.'
+		)
+	else:
+		for d in tqdm(item_list, desc='Dir Combining...'):
+			s = str(d).replace(os.path.sep, '-')
+			des_path = saveout_dir.resolve() / s 
+
+			# copy or move
+			if move:  
+				shutil.move(str(d.resolve()), str(des_path))
+			else:
+				shutil.copy(str(d.resolve()), str(des_path))
+
+
+	# saveout log
+	CONSOLE.log(f"Saved at: [u green]{saveout_dir}")
+
+	
+
+def run_dir_combine(args: DictConfig):
+	# called by run.py
+
+	dir_combine(
+		input_dir=args.input_dir,
+		output_dir=args.output_dir,
+		fmt=args.fmt,
+		move=args.move
+	)
 
 
-if __name__ == "__main__":
-    opt = parse_opt()
-    dir_combine(input=opt.input,
-				output=opt.output,
-				suffix=opt.suffix,
-				move=opt.move)
```

## usls/src/labelling_det.py

```diff
@@ -1,61 +1,51 @@
-
 import argparse
 import os
 import re
 import cv2
 import numpy as np
 from tqdm import tqdm
 from pathlib import Path
 import sys
 import shutil
 import random
 import time
-# from loguru import logger as LOGGER
 import json
 import rich
+from omegaconf import OmegaConf, DictConfig
 
 
+from usls.src.utils import Colors, IMG_FORMAT, is_point_in_rect, CONSOLE
 
-#--------------------------------------------
-#       ADD TO PYTHON_PATH
-#--------------------------------------------
-FILE = Path(__file__).resolve()
-ROOT = FILE.parents[0]   # FILE.parent 
-if str(ROOT) not in sys.path:
-    sys.path.append(str(ROOT))  # add ROOT to PATH
-#--------------------------------------------
-
-from utils import Colors, IMG_FORMAT, is_point_in_rect, LOGGER, CONSOLE
 
 
 #--------------------------------------------
 #          Global Variables
 #--------------------------------------------
 
 HELP_MSG = '''
 
-[bold]Usage:
-    [green]ESC:                    [cyan]quit 
-    [green]r/R:                    [cyan]switch mode between `mark` and `read`
-    [green]a(A)/d(D):              [cyan]switch image
-    [green]w(W)/s(S):              [cyan]switch class
-    [green]-/+:                    [cyan]adjust line-thickness
-    [green]t/T:                    [cyan]switch line-thickness between thickness=1 and thickness=current
-    [green]n/N:                    [cyan]hide all bboxes' labels
-    [green]b/B:                    [cyan]blink the bboxes & labels
-    [green]l/L:                    [cyan]shuffle bbox colors
-    [green]i/I:                    [cyan]display info
-    [green]0-8:                    [cyan]show single class bboxes
-    [green]9:                      [cyan]show all classes bboxes
-    [green]delete:                 
-                            [cyan]way 1. press `c/C` to remove all bboxes and txt label.
-                            [cyan]way 2. press  r/R to enter `mark` mode, then click right button on bbox you're about to delete. txt label not included
-    [green]select bbox:            [cyan]press r/R, then double click one bboxes to select it.
-    [green]change bbox's class:    [cyan]select bbox first, then press `w/s` to change its'class. 
+Usage:
+    ESC:                    Quit 
+    r/R:                    Switch mode between Mark and Read
+    a(A)/d(D):              Last or next image
+    w(W)/s(S):              Last or next label classes
+    -/+:                    Adjust line thickness
+    t/T:                    Switch line thickness between thickness=1 and thickness=current
+    n/N:                    Hide all bboxes' labels
+    b/B:                    Blink the bboxes & labels
+    l/L:                    Shuffle bbox colors randomly
+    i/I:                    Display current image info
+    0-8:                    Show bboxes classes-correspondingly
+    9:                      Show all bboxes
+    delete:                 - way 1. press `c/C` to remove all bboxes and delete label file.
+                            - way 2. right button click on bbox in MARK mode. And label
+                            file will not be deleted.
+    select bbox:            press r/R, then double click one bboxes to select it.
+    change bbox's class:    select bbox first, then press `w/s` to change it's class. 
 '''
 
 
 # windows 
 WINDOW_NAME = 'Detection-Labelling'
 
 # tracker bars
@@ -125,15 +115,15 @@
     global WINDOW_NAME
 
     if where == 'Overlay':
         cv2.displayOverlay(WINDOW_NAME, text, ms)
     elif where == 'Statusbar':
         cv2.displayStatusBar(WINDOW_NAME, text, ms)
     else:
-        LOGGER.info(f"{text}")
+        CONSOLE.log(f"{text}")
 
 
 
 # index -1
 def decrease_index(current_idx, max_idx):
     current_idx -= 1
     if current_idx < 0:
@@ -187,15 +177,16 @@
     cx = float((point_1[0] + point_2[0]) / (2.0 * img_w) )
     cy = float((point_1[1] + point_2[1]) / (2.0 * img_h))
     w = float(abs(point_2[0] - point_1[0])) / img_w
     h = float(abs(point_2[1] - point_1[1])) / img_h
     
     # double check of boundary
     if not all([0 <= x <= 1 for x in [cx, cy, w, h]]):
-        LOGGER.error(f"Wrong coordination of cx, cy, w, h!")
+        CONSOLE.log(f"Wrong coordination of cx, cy, w, h!")
+        sys.exit()
         
         # todo
 
 
     items = map(str, [cls_idx, cx, cy, w, h])
     return ' '.join(items)
 
@@ -524,27 +515,27 @@
 
 def opencv_window_init():
     # init window with overlap
     try:
         cv2.namedWindow('Test')   
         cv2.displayOverlay('Test', 'Test overlap', 10)  
         cv2.displayStatusBar('Test', 'Test status bar', 10)
-    except cv2.error:
-        print('-> Please ignore this error message\n')
+    except cv2.error as e:
+        CONSOLE.log(f"Exception: {e}")
     cv2.destroyAllWindows()   
 
 
 
 
 # ---------------------------------------------------
 #   inspect : main for calling
 #--------------------------------------------------
 def inspect( img_dir, 
              label_dir,
-             mv_dir,
+             # mv_dir,
              wrong_img_dir,
              classes,
              window_width=800,
              window_height=600,
              ):
     
     # global vars
@@ -557,28 +548,28 @@
            PRVE_WAS_DOUBLE_CLICK, IS_BBOX_SELECTED, SELECTED_BBOX, MOUSE_X, MOUSE_Y, POINT_1, POINT_2,\
            IMG_COUNT, CLS_COUNT
     
 
     # input img dir & label dir
     INPUT_IMG_DIR  = img_dir
     INPUT_LABEL_DIR = label_dir if label_dir else INPUT_IMG_DIR
-    LOGGER.info(f"IMG   DIR: {Path(INPUT_IMG_DIR).resolve()}")
-    LOGGER.info(f"LABEL DIR: {Path(INPUT_LABEL_DIR).resolve()}")
+    CONSOLE.log(f"IMG   DIR: {Path(INPUT_IMG_DIR).resolve()}")
+    CONSOLE.log(f"LABEL DIR: {Path(INPUT_LABEL_DIR).resolve()}")
 
     #-----------------------------------------   
     WINDOW_INIT_WIDTH = window_width    # initial window width
     WINDOW_INIT_HEIGHT = window_height    # initial window height
 
     # mark mode 
     MARK_MODE = False
     CLASSIFY_MODE = False
 
     # wrong dir & move dir
     WRONG_IMG_DIR = wrong_img_dir
-    MV_DIR = mv_dir
+    # MV_DIR = mv_dir
 
     # hide label
     HIDE_LABEL = False
 
     # num_bboxes
     # HIDE_NUM_BBOXES = False
 
@@ -593,37 +584,33 @@
     BLINK_OR_NOT = False
 
     # line thickness  &  line thickes adjust
     LINE_THICKNESS = 1            
     LINE_THICKNESS_ADJUST = False   # line thickness adjust flag
 
     # ----------------------
-    # CLASS_LIST
+    #   CLASS_LIST
     # ----------------------
-    if len(classes) == 0:   # no classes
-        LOGGER.error("Error: <--inspect> should work with <--classes>! EXIT!")
-        exit(-1)
-    elif len(classes) == 1 and classes[0].endswith('.txt'):    # txt input
+    if len(classes) == 1 and classes[0].endswith('.txt'):    # txt input
         with open(classes[0]) as f:
             for line in f:
                 CLASS_LIST.append(line.strip())
-    else: # args classes 
+    else:   # args classes 
         CLASS_LIST = classes
 
-    # repeat class check 
-    if not (len(CLASS_LIST) == len(set(CLASS_LIST))):
-        LOGGER.error("Repeat class name!!!")
-        exit(-1)
+
 
     # opencv windows init
     opencv_window_init()
 
     # read all input images
-    LOGGER.info(f"Loading all images...")
-    IMAGE_PATH_LIST = sorted([str(x) for x in Path(INPUT_IMG_DIR).iterdir() if x.suffix.lower() in IMG_FORMAT], key=cmp)
+    with CONSOLE.status("[bold cyan]Loading images...") as status:
+        IMAGE_PATH_LIST = sorted([str(x) for x in Path(INPUT_IMG_DIR).iterdir() if x.suffix.lower() in IMG_FORMAT], key=cmp)
+    CONSOLE.log(f"Images loaded ✅")
+
 
     # image class json file init
     IMAGE_CLASSES_JSON_PATH = Path(INPUT_IMG_DIR).with_name('classify.json')
 
     # load json for classify task
     if (IMAGE_CLASSES_JSON_PATH).exists():
         IMAGE_CLASSES = json.load(open(IMAGE_CLASSES_JSON_PATH, encoding="utf-8"))
@@ -654,20 +641,19 @@
         # cv2.createTrackbar(TRACKBAR_CLASS + '\n' + str(classes) + '\n', WINDOW_NAME, 0, CLS_COUNT, set_class_index)
         # cv2.createTrackbar(TRACKBAR_CLASS + '\n' + str(classes) + '\n', WINDOW_NAME, 0, CLS_COUNT, lambda x: None)
 
     # initialize the img index
     set_img_index(0)
 
     # help info
-    rich.print(f"{HELP_MSG}")
+    CONSOLE.log(f"{HELP_MSG}")
 
 
     # colors palette
     COLOR_PALETTE = Colors(shuffle=False)  
-    # LOGGER.info(f"running...")
 
     with CONSOLE.status("[bold cyan]Doing inspect...") as status:
 
         # loop
         while True:
             color = COLOR_PALETTE(int(CLS_IDX_CURRENT), bgr=False)  # color for every class
             tmp_img = IMG_CURRENT.copy()    # clone the img   
@@ -1012,19 +998,19 @@
             # check if json file is same with IMAGE_CLASS
             assert json.load(open(IMAGE_CLASSES_JSON_PATH, encoding="utf-8")) == IMAGE_CLASSES
 
             # in case of other keys input
             while True: 
                 response = input('> Find classify.json! Do classifying? [yes / no]: ')
                 if response.lower() in ('n', 'no'):   # exit
-                    LOGGER.info('Not doing classifying')
+                    CONSOLE.log('Not doing classifying')
                     break
 
                 elif response.lower() in ('y', 'yes'):
-                    LOGGER.info('Doing classifying')
+                    CONSOLE.log('Doing classifying')
 
 
                     # iterate IMAGE_CLASSES to move image to dirs
                     for idx, (k, v) in enumerate(tqdm(IMAGE_CLASSES.items(), desc='Classifying')):
                         # print(f'{idx} --> {k} --> {v}')
 
                         # mkdir dirs for different class: CLASS/class_a, CLASS/class_b, CLASS/class_c 
@@ -1040,60 +1026,42 @@
 
 
         # ---------------------------
         # deal with wrong img
         # last step: 删除所有无法被opencv读取的图像
         # ---------------------------
         if len(WRONG_IMG_SET) > 0:
-            LOGGER.warning(f"has {len(WRONG_IMG_SET)} images can not be read by OpenCV, moving to {WRONG_IMG_DIR}")
+            CONSOLE.log(f"has {len(WRONG_IMG_SET)} images can not be read by OpenCV, moving to {WRONG_IMG_DIR}")
             
             # create dir if not exist
             if not Path(WRONG_IMG_DIR).exists():
                 Path(WRONG_IMG_DIR).mkdir()
 
             # remove
             for img in WRONG_IMG_SET:
                 shutil.move(img, WRONG_IMG_DIR)
-                LOGGER.info(f"{Path(img).resolve()}")
+                CONSOLE.log(f"{Path(img).resolve()}")
 
         else:
-            LOGGER.info(f"\n> Every image can be read by OpenCV.\n")
-
-
+            CONSOLE.log(f"\n> Every image can be read by OpenCV.\n")
 
 
 
 
 
-# ----------------options ------------------------
-def parse_opt():
-    parser = argparse.ArgumentParser(description='Open-source image labeling tool')
-    parser.add_argument('--img-dir', default='img-dir', type=str, help='Path to input directory')
-    parser.add_argument('--label-dir', default='', type=str, help='Path to output directory')
-    parser.add_argument('--mv-dir', default="moved_dir", type=str, help='mv-dir to save moved data[img, label]')
-    parser.add_argument('--wrong-img-dir', default="wrong-img-dir", type=str, help='wrong format img to save imgs opencv cant read')
-    parser.add_argument('--classes', default='', nargs="+", type=str, help='classes list text')
-    parser.add_argument('--window_width', default=800, type=int, help='classes list text')
-    parser.add_argument('--window_height', default=600, type=int, help='classes list text')
-    opt = parser.parse_args()
-    # LOGGER.info(f"{opt}\n")
 
-    return opt
 
+def run_inspect(args: DictConfig):
 
+    inspect( 
+        img_dir=args.img_dir, 
+        label_dir=args.label_dir if args.label_dir else args.img_dir,
+        wrong_img_dir=args.depreacated_dir,
+        # classes=args.classes.split(',') if isinstance(args.classes, str) else OmegaConf.to_container(args.classes),
+        classes=args.classes,
+        window_width=args.window_width,
+        window_height=args.window_height,
+    )
 
 
 
-# ---------------------------------------------------
-#   main
-#--------------------------------------------------
-if __name__ == '__main__':
 
-    opt = parse_opt()
-    inspect( opt.img_dir, 
-             opt.label_dir,
-             opt.mv_dir,
-             opt.wrong_img_dir,
-             opt.classes,
-             opt.window_width,
-             opt.window_height,
-             )
```

## usls/src/spider.py

```diff
@@ -1,130 +1,138 @@
 from baiduspider import BaiduSpider
-from pprint import pprint
 from tqdm import tqdm
 import urllib
 from pathlib import Path
 import rich
 import sys
-import argparse
+import re
+from omegaconf import OmegaConf, DictConfig
+from typing import Dict, List
+
+
+from usls.src.utils import CONSOLE, IMG_FORMAT, VIDEO_FORMAT, LABEL_FORMAT, increment_path
 
 
-#--------------------------------------------
-#       ADD TO PYTHON_PATH
-#--------------------------------------------
-FILE = Path(__file__).resolve()
-ROOT = FILE.parents[0]   # FILE.parent 
-if str(ROOT) not in sys.path:
-    sys.path.append(str(ROOT))  # add ROOT to PATH
-# ROOT = Path(os.path.relpath(ROOT, Path.cwd()))  # abs path => relative
-#--------------------------------------------
 
 
-from utils import LOGGER, increment_path
-
-
-
-
-
-# ----------------options ------------------------
-def parse_opt():
-    parser = argparse.ArgumentParser(description='Open-source image labeling tool')
-
-    # basic directory
-    parser.add_argument('--words', default='', type=str, nargs="+", help='multi word use space to sep.', required=True)
- 
-    opt = parser.parse_args()
-    rich.print(f"[bold white]=>({FILE.name})[/bold white] : [bold]{opt}\n")
-    return opt
-
-
-
-# main
-def spider_img_baidu(words):
-
-	rich.print(f"[bold magenta]------baidu spider for images--------")
-
-	# print(opt.keywords)
-	keywords = " ".join(words)
-
-	# get info
-	response = BaiduSpider().search_pic(keywords)
-	image_num = response.total
-	page_num = response.pages
-	LOGGER.info(f"Image_num: {image_num}  |  Page_num: {page_num}")
+def spider_baidu_image(
+		words,
+		output_dir,
+	):
+	# assert isinstance(word, str), f'[b green]{word}[/b green] [red]is not type of string!'
+
+
+	responses = []
+	for word in words:
+		responses.append(BaiduSpider().search_pic(word))
+
+
+	# get global info
+	# response = BaiduSpider().search_pic(word)
+
+	table = rich.table.Table(
+		title='\nbaidu image spider', 
+		# title_style='left',
+		box=rich.box.ASCII,   # box.MARKDOWN ,SIMPLE   , rich.box.ASCII2
+		show_lines=False, 
+		show_header=True,
+		caption='',
+		caption_justify='center',
+		header_style='',
+		# show_footer=True,
+	)
+
+	table.add_column(
+		header="Words", 
+		footer='',
+		justify="left", 
+		# style="b", 
+		no_wrap=False
+	)
+	table.add_column(
+		header="Pages Found", 
+		footer='',
+		justify="left", 
+		# style="b", 
+		no_wrap=False
+	)
+	table.add_column(
+		header="Images Found", 
+		footer='',
+		justify="left", 
+		# style="b", 
+		no_wrap=False
+	)
+
+	for i in range(len(words)):
+		table.add_row(f"{words[i]}", f"{responses[i].pages}", f"{responses[i].total}", end_section=False)
+	CONSOLE.print(table)
 
 
 	# interact with user about page start & end.
-	input_c = input("=> Input two numbers, page_start & page_end, use space to seperate: ")
-	c = input_c.strip().split()
-	if len(c) != 2:
-		LOGGER.error(f"Wrong input! Should has two numbers!")
-		exit()
-
-	page_start = int(c[0])
-	page_end = int(c[1])
-	if page_start > page_end:
-		LOGGER.error(f"Error: page start > page end!")
-		exit()
-
-	LOGGER.info(f"It will spider from page {page_start} to page {page_end}")
-
-
-	# saveout dir
-	dir_name = "baidu-img-spider"
-	project = "_".join(words)
-	save_dir = increment_path(Path(dir_name)/project, exist_ok=False, sep='')  # increment run
-
-	# loop
-	for n in tqdm(range(page_start, page_end)):
-
-		print(f"[bold green]==> {n}")
-
-		# spider
-		res = BaiduSpider().search_pic(keywords, n)
-
-		# make dir for every page
-		(save_dir / str(n)).mkdir(parents=True, exist_ok=True)
-
-		# loop to save
-		plain = res.__dict__['plain']
-		for idx, item in tqdm(enumerate(plain)):
-			url = item['url']
-
-			try:
-				saveout = Path(save_dir / str(n) / (str(idx) + '.jpg')) 
-				urllib.request.urlretrieve(str(url), filename=str(saveout))
-			# except [urllib.error.ContentTooShortError, urllib.error.HTTPError]:
-			except Exception as error:
-				print("[error]:", error)
-
-				# continue
-			# finally:
-				# continue
-
-
-# ---------------------------------------------------
-#   main
-#--------------------------------------------------
-if __name__ == '__main__':
-	# options
-	opt = parse_opt()
-	spider_img_baidu(opt.words)
-
-
-	# res = BaiduSpider().search_pic(query='安全带')
-	# plain = res.__dict__['plain']
-	# pprint(type(plain))
-	#pprint(plain[-1])
-	# pprint(res.total)
-	# pprint(res.pages)
-	# pprint(len(res.plain))
-
-	# for idx, item in tqdm(enumerate(plain)):
-	# 	# pprint(item['url'])
-	# 	# print('-----')
-
-	# 	url = item['url']
-	# 	saveout_dir = "test"
-	# 	saveout = Path(saveout_dir) / (str(idx)+'.jpg')
-	# 	urllib.request.urlretrieve(str(url) , filename=str(saveout))
+	CONSOLE.log(f"😁 Give me 2 numbers(page begin & end, seperated by whatever you want).")
+	page_begin, page_end = list(), list()
+	for i, word in enumerate(words):
+		_count = 0
+		while True:
+			_count += 1  # attempt counter
+			_input = CONSOLE.input(
+				# prompt=f"{word} | 😁 Give me 2 numbers(page begin & end, seperated by whatever you want).\n> "
+				prompt=f"{word} > "
+			)
+			c = re.findall('\d+', _input)
+
+			if len(c) != 2:
+				if _count == 1:
+					CONSOLE.log(f"[b red]🙂 Two Numbers! Do it again!")
+				elif _count == 2:
+					CONSOLE.log(f"[b red]🙃 What's wrong with you! 2! Numbers!")
+				else:
+					CONSOLE.log(f"[b red]🤬 Fuck you! Mother-fucker! Fuck offffff!")
+					sys.exit()
+			elif int(c[0]) >= int(c[1]):
+				CONSOLE.log(f"[b red]😑 Page_begin should be less than page end!!")
+			elif int(c[0]) < 0:
+				CONSOLE.log(f"[b red]😑 Page_begin should be grater than 0!!")
+			elif int(c[1]) > responses[i].pages:
+				CONSOLE.log(f"[b red]😑 Page_end should be less than max num_page!!")
+			else:
+				# page_begin, page_end = int(c[0]), int(c[1])
+				page_begin.append(int(c[0]))
+				page_end.append(int(c[1]))
+				break
+
+
+	for i, word in enumerate(tqdm(words, desc='Downloading...')):
+
+		# saveout dir
+		save_dir = increment_path(Path(output_dir)/word, exist_ok=False, sep='-')  # increment run
+
+		# loop
+		for n in range(page_begin[i], page_end[i]):
+			
+			res = BaiduSpider().search_pic(word, n)  # spider
+			(save_dir / str(n)).mkdir(parents=True, exist_ok=True)  # make dir for every page
+
+			# loop to save
+			plain = res.__dict__['plain']
+			for idx, item in enumerate(plain):
+				url = item['url']
+				try:
+					saveout = Path(save_dir / str(n) / (str(idx) + '.jpg')) 
+					urllib.request.urlretrieve(str(url), filename=str(saveout))
+				# except [urllib.error.ContentTooShortError, urllib.error.HTTPError]:
+				except Exception as error:
+					# print(error)
+					continue
+					# pass
+				# finally:
+				# 	continue
+
+
+
+def run_spider(args: DictConfig):
+	spider_baidu_image(
+		words=args.words,
+		output_dir=args.output_dir
+	)
```

## usls/src/utils.py

```diff
@@ -8,343 +8,126 @@
 from tqdm import tqdm
 import sys
 import random
 import time
 import logging
 import glob
 import re
-import hydra
 import rich
 from rich.console import Console
-import psutil
 from datetime import datetime
-import pynvml
 import contextlib
 import numpy as np
 from dataclasses import dataclass
 from typing import Union
+from PIL import ExifTags, Image, ImageOps
+import hashlib
+from loguru import logger as LOGGER
 
 
+CONSOLE = Console()
 IMG_FORMAT = ('.jpg', '.jpeg', '.png', '.bmp')
+LABEL_FORMAT = ('.txt', '.xml', '.yaml', '.csv')
 VIDEO_FORMAT = ('.mp4', '.flv', '.avi', '.mov')
-CONSOLE = Console()
+ASCII_LETTERS = 'abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ'
 
 
-def CLI_MSG_TABLE():
-    table = rich.table.Table(
-        title='', 
-        title_style='left',
-        box=rich.box.ASCII2, 
-        show_lines=False, 
-        caption='usls\n',
-        caption_justify='center',
-        header_style='bold cyan',
-    )
-
-
-    table.add_column(
-        "Usage", 
-        justify="left", 
-        style="b", 
-        no_wrap=False
-    )
-    table.add_column(
-        "Command", 
-        justify="left", 
-        style="green", 
-        no_wrap=False
-    )
-
-
-    table.add_row(f"-h, -H, --help", f"usls --help", end_section=False)
-    table.add_row(f"-v, -V, --version", f"usls --version", end_section=True)
-    table.add_row(f"Format", f"usls task=... args=... (task can be omitted)", end_section=True)
-    table.add_row(
-        f"Detection Labelling", 
-        f"usls inspect img_dir=..., [label_dir=...] classes=sth,sth,sth", 
-        end_section=False
-    )
-    table.add_row(
-        f"Classification Labelling", 
-        f"usls classify img_dir=... [label_dir=...] classes=sth,sth,sth", 
-        end_section=False
-    )
-    table.add_row(
-        f"info", 
-        f"usls info img_dir=... [label_dir=... video_dir=...]", 
-        end_section=False
-    )
-    table.add_row(
-        f"clean-up", 
-        f"usls info img_dir=... [label_dir=... mv_dir=... clean_empty=True]", 
-        end_section=False
-    )
-    table.add_row(
-        f"combine labels", 
-        f"usls label_combine input_dir=... [output_dir=...]", 
-        end_section=False
-    )
-    table.add_row(
-        f"combine directories", 
-        f"usls dir_combine input_dir=... [output_dir=... suffix=[] move=False]", 
-        end_section=False
-    )
-    table.add_row(
-        f"Video -> Images", 
-        f"usls v2is source=... [output_dir=v2is frame=20 view=False flip=False fmt_img=.jpg]", 
-        end_section=False
-    )
-    table.add_row(
-        f"Videos -> Images", 
-        f"usls vs2is input_dir=... [output_dir=v2is frame=20 view=False flip=False fmt_img=.jpg]", 
-        end_section=False
-    )
-    table.add_row(
-        f"Images -> Video", 
-        f"usls is2v input_dir=... [output_dir=vs2is fps=30 last4=60 video_size=640]", 
-        end_section=False
-    )
-    table.add_row(
-        f"Play videos/streams & Record(r/R)", 
-        f"usls play source=... [delay=1 flip=False]", 
-        end_section=False
-    )
-    table.add_row(
-        f"Spider", 
-        f"usls spider words=sth", 
-        end_section=False
-    )
-    table.add_row(
-        f"De-duplicate", 
-        f"usls deduplicate input_dir=... [mv_dir=...]", 
-        end_section=False
-    )
-    table.add_row(
-        f"Label Class Modify", 
-        f"usls class_modify input_dir=... to=...", 
-        end_section=False
-    )
-
-    # CONSOLE.print(table)
-    return table
-
-
-def setup_logging_plain(
-        stream_logger_name=None, 
-        stream_level=logging.DEBUG,
-    ):
-
-    # stream logger 
-    stream_logger = logging.getLogger(stream_logger_name)
-    stream_logger.setLevel(stream_level)
-
-    stream_handler = logging.StreamHandler() 
-    stream_handler.setFormatter(logging.Formatter("[%(levelname)s] %(message)s"))
-    stream_handler.setLevel(stream_level)
-    stream_logger.addHandler(stream_handler)  
-    return stream_logger
-
-LOGGER = setup_logging_plain(__name__)
-
-
-# increase python path
-def add_python_path(verbose=False):
-	for child in list(Path(__file__).resolve().parents):
-		sys.path.append(str(child))
-	if verbose:	
-		rich.print(sys.path)
-
-
-
-class INSPECTOR(contextlib.ContextDecorator):
-
-    def __init__(self, prefix='Time', cpu=False, mem=False, gpu=False):
-        self.prefix = prefix
-        self.cpu, self.mem, self.gpu = cpu, mem, gpu
-
-
-    def __enter__(self):
-        self.t0 = time.time()
-
-        if self.cpu:
-            self.cpu_usage_avg0 = psutil.cpu_percent(percpu=False, interval=None)
-
-        if self.mem:
-            self.mem0 = psutil.virtual_memory().used
-
-        if self.gpu:
-            pass
-
-        return self
-
-
-    def __exit__(self, type, value, traceback):
-        self.duration = time.time() - self.t0  
-        CONSOLE.log(f"{self.prefix} | Time consume: {(time.time() - self.t0) * 1e3:.2f} ms.")
-
-        if self.cpu:
-            CONSOLE.log(f"{self.prefix} | CPU cost: {(psutil.cpu_percent(percpu=False, interval=None) - self.cpu_usage_avg0)} %.")
-            # CONSOLE.log(f"{self.prefix} | start: {self.cpu_usage_avg0} | end: {(psutil.cpu_percent(percpu=False, interval=None))} | CPU cost: {(psutil.cpu_percent(percpu=False, interval=None) - self.cpu_usage_avg0)} %.")
-
-        if self.mem:
-            CONSOLE.log(f"{self.prefix} | Memory cost: {(psutil.virtual_memory().used - self.mem0) / GB:.3f} %.")
-            # CONSOLE.log(f"{self.prefix} | start: {self.mem0 / GB} | end: {psutil.virtual_memory().used / GB} | Memory cost: {(psutil.virtual_memory().used - self.mem0) / GB:.3f} %.")
-
-        if self.gpu:
-            pass
-
-
-
-    def __call__(self, func):
-        def wrapper(*args, **kwargs):
-            t0 = time.time()
-            ret = func(*args, **kwargs)
-            CONSOLE.log(f"{self.prefix} consume: {(time.time() - t0) * 1e3:.2f} ms.")
-            return ret
-        return wrapper
-
-
-
-
-def exif_size(img):
-    # Returns exif-corrected PIL size
-    s = img.size  # (width, height)
-    try:
-        rotation = dict(img._getexif().items())[orientation]
-        if rotation == 6:  # rotation 270
-            s = (s[1], s[0])
-        elif rotation == 8:  # rotation 90
-            s = (s[1], s[0])
-    except:
-        pass
-
-    return s
-
-
-# TODO
-def verify_images(path):
-
-    try:
-        # PIL read img
-        im = Image.open(path)
-        
-        # PIL image quality check
-        im.verify()
 
-        # size < 10x10 will be  an error
-        shape = exif_size(im)  # image size
-        assert (shape[0] > 9) & (shape[1] > 9), f'image size {shape} <10 pixels'
-
-        # jpg & jpeg corrupt check
-        if im.format.lower() in ('jpeg', 'jpg'):
-            with open(path, "rb") as f:
-                f.seek(-2, 2)
-                if f.read() != b'\xff\xd9':  # corrupt JPEG
-                    ImageOps.exif_transpose(Image.open(path)).save(path, 'JPEG', subsampling=0, quality=100)
-                    LOGGER.warning(f"WARNING: {path}: corrupt JPEG restored and saved")
+def natural_sort(x, _pattern=re.compile('([0-9]+)'), mixed=True):
+    return [int(_x) if _x.isdigit() else _x for _x in _pattern.split(str(x) if mixed else x)]
 
-    except Exception as e:
-        LOGGER.warning(f"Exceptions: {e}")
 
 
-def verify_label(path):
-    pass
+def time_now():
+    return datetime.now().strftime('%Y-%m-%d %H:%M:%S')
 
 
-# img_list & label_list, relative path
-def load_img_label_list(img_dir, label_dir, img_format, info=True):
-    image_list = [x for x in Path(img_dir).iterdir() if x.suffix in img_format]
-    label_list = list(Path(label_dir).glob("*.txt"))
-    
-    if info:
-        rich.print(f"[green]> Images count: {len(image_list)}")
-        rich.print(f"[green]> Labels count: {len(label_list)}")
-        
+def get_md5(f):
+    m = hashlib.md5(open(f,'rb').read())
+    return m.hexdigest()
 
-    return image_list, label_list
+
+def gen_random_string(length):
+    return ''.join(random.choices(ASCII_LETTERS, k=length))
 
 
-def load_from_dir(
-        img_dir, 
-        label_dir=None, 
-        video_dir=None, 
-        img_format=IMG_FORMAT,
-        video_format=VIDEO_FORMAT, 
-        verbose=True,
-        title='',
-        caption='',
-    ):
+def get_common_files(directory):
 
-    # img_dir = opt.get('img_dir')
-    # label_dir = opt.label_dir if opt.get('label_dir') else img_dir
+    # file list
+    f_list = list()
+    for x in Path(directory).iterdir():
+        if str(x).startswith('.'):   # hidden file, leave it
+            continue
+        if x.suffix == '':   # no suffix
+            if x.is_dir():
+                f_list.append(x)    # dir, append
+        else:
+            f_list.append(x)    # has suffix, append
 
-    # erroe checking
-    if not Path(img_dir).is_dir():
-        raise TypeError(f'img_dir should be directory, not {type(img_dir)}')
+    return f_list
 
-    if label_dir and not Path(label_dir).is_dir():
-        raise TypeError(f'label_dir should be directory, not {type(label_dir)}')
 
-    if video_dir and not Path(video_dir).is_dir():
-        raise TypeError(f'video_dir should be directory, not {type(video_dir)}')
+def verify_images(path, output_dir):
+    _check_again = True  # flag
 
+    # PIL check 1st, and restore corrupt JPEG
+    try: 
+        with Image.open(path) as im:
+            im.verify()   # PIL image quality check
+
+            # jpg & jpeg corrupt check
+            if im.format.lower() in ('jpeg', 'jpg'):
+                with open(path, "rb") as f:
+                    f.seek(-2, 2)
+                    if f.read() != b'\xff\xd9':     # corrupt JPEG
+                        ImageOps.exif_transpose(Image.open(path)).save(path, 'JPEG', subsampling=0, quality=100)
+                        CONSOLE.log(f"Corrupt JPEG restored and saved | {path}")
+    except OSError:
+        CONSOLE.log(f"PIL verify failed! | {path}")
+        shutil.move(str(path), str(output_dir))
+        _check_again = False  # set flag
+        # integrity = False
+        return False
+
+
+    # opencv check again
+    if _check_again:
+        try:
+            if cv2.imread(str(path)) is None:  # get md5 of each image
+                shutil.move(str(path), str(output_dir))
+                return False
+        except Exception as e:
+            CONSOLE.log(f"opencv exceptions: {e} | {path}")
+            return False
 
-    label_dir = label_dir if label_dir else img_dir 
-    video_dir = video_dir if video_dir else img_dir 
+    return True
 
 
-    image_list = [x for x in Path(img_dir).iterdir() if x.suffix.lower() in img_format]
-    video_list = [x for x in Path(img_dir).iterdir() if x.suffix.lower() in video_format]
+# img_list & label_list, relative path
+def load_img_label_list(img_dir, label_dir, img_format, info=True):
+    image_list = [x for x in Path(img_dir).iterdir() if x.suffix in img_format]
     label_list = list(Path(label_dir).glob("*.txt"))
     
-    if verbose:
-
-        # display
-        table = rich.table.Table(
-            title=title, 
-            title_style='left',
-            box=rich.box.ASCII2, 
-            show_lines=False, 
-            caption=caption,
-            caption_justify='center',
-            # header_style='bold cyan',
-        )
-        table.add_column(
-            "Type", 
-            justify="left", 
-            style="b", 
-            no_wrap=False
-        )
-        table.add_column(
-            "Count", 
-            justify="right", 
-            style="b green", 
-            no_wrap=False
-        )
-
-        table.add_row(f"Images{img_format}", f"{len(image_list)}", end_section=True)
-        table.add_row(f"Labels(.txt)", f"{len(label_list)}", end_section=True)
-        table.add_row(f"Videos{video_format}", f"{len(video_list)}", end_section=True)
-        CONSOLE.print(table)
-
-
-
-    return image_list, label_list, video_list
+    if info:
+        rich.print(f"[green]> Images count: {len(image_list)}")
+        rich.print(f"[green]> Labels count: {len(label_list)}")
+        
 
+    return image_list, label_list
 
 
 
 # img_path => label_path(txt)
 def get_corresponding_label_path(img_path, output_dir):
     label_name = Path(img_path).stem + '.txt'
     saveout = Path(output_dir) / label_name 
     return str(saveout)
 
 
-# √ Check if a point belongs to a rectangle
+# Check if a point belongs to a rectangle
 def is_point_in_rect(x, y, l, t, r, b):
     return l <= x <= r and t <= y <= b
 
 
 # colors palette
 class Colors:
     '''
@@ -383,365 +166,30 @@
     @staticmethod  
     def hex2rgb(h):  # int('CC', base=16) 将16进制的CC转成10进制 
         return tuple(int(h[1 + i:1 + i + 2], 16) for i in (0, 2, 4))
 
 
 
 
-
-
-# -------------------------------------
-# mode: check img_label_pair 
-# 1. 检查是否所有的img都有对应lable；  done
-# 2. 是否所有的label都有对应img; 
-# 3. 并且检查是否所有的label都是有内容的
-# 将不满足的img和label移除到 mv_dir
-# 4. img dir 仅仅可以存在支持的IMG_FORMAT文件
-# 5. label dir 仅仅可以存在.txt文件
-# -------------------------------------
-def img_label_dir_cleanup(
-        input_img_dir, 
-        input_label_dir, 
-        mv_dir, 
-        img_format, 
-        info=True, 
-        dont_clean_empty_txt=False,
-        verbose=False,
-    ):
-
-    # load img and label
-    # image_list, label_list = load_img_label_list(
-    #     input_img_dir, input_label_dir, img_format, info
-    # )
-
-    image_list, label_list, video_list = load_from_dir(
-        img_dir=input_img_dir, 
-        label_dir=input_label_dir, 
-        video_dir=None, 
-        verbose=True,
-        title='\nbefore',
-        caption='',
-    )
-
-
-    # create mv-dir if not exist
-    if not Path(mv_dir).exists():
-        Path(mv_dir).mkdir()
-
-
-    # 1. 检查是否所有的image都有对应的label
-    # has img, no label => remove img
-    for image_path in tqdm(image_list, desc=f"Checking images"):
-
-        # has corresponding label, continue
-        if Path(input_label_dir) / (image_path.stem + '.txt') in label_list:
-            continue
-
-        # else remove img
-        if verbose:
-            LOGGER.warning(f"No corresponding label: {image_path}, moved.")
-        shutil.move(str(image_path), mv_dir)  
-
-
-    # 2. 剩余的所有image都有对应的label，size(img) <= size(label)
-    # 检查是否所有的label都有对应的image
-    # has label, no img  => remove label 
-    
-    # image_list, label_list = load_img_label_list(input_img_dir, input_label_dir, img_format, info)
-    image_list, label_list, video_list = load_from_dir(
-        img_dir=input_img_dir, 
-        label_dir=input_label_dir, 
-        video_dir=None, 
-        verbose=False
-    )
-    for label_path in tqdm(label_list, desc=f"Checking labels"):      
-
-        # remove label file without corresponding img
-        if Path(input_img_dir) / (label_path.stem + '.png') in image_list:
-            continue
-        elif Path(input_img_dir) / (label_path.stem + '.jpg') in image_list:
-            continue
-        elif Path(input_img_dir) / (label_path.stem + '.jpeg') in image_list:
-            continue
-        else:
-            # rich.print(f"[bold red]No corresponding img: {label_path}, moved.")
-            if verbose:
-                LOGGER.warning(f"No corresponding img: {label_path}, moved.")
-            shutil.move(str(label_path), mv_dir)
-
-
-
-    # 3. 检查所有label都有内容，不是空的; 此刻，size(img) = size(label)
-    # empty label => remove img & label 
-    if not dont_clean_empty_txt:
-        # rich.print(f"> Checking if all labels are not empty...")
-        # image_list, label_list = load_img_label_list(input_img_dir, input_label_dir, img_format, info)
-        image_list, label_list, video_list = load_from_dir(
-            img_dir=input_img_dir, 
-            label_dir=input_label_dir, 
-            video_dir=None, 
-            verbose=False
-        )
-
-
-        for label_path in tqdm(label_list, desc=f"Checking empty labels"):   
-
-            # size < 10 => empty
-            if os.path.getsize(str(label_path)) < 10:
-
-                # revome label & img
-                # rich.print(f"[bold red]Empty label file: {label_path}, moved.")
-                if verbose:
-                    LOGGER.warning(f"Empty label file: {label_path}, moved.")
-                shutil.move(str(label_path), mv_dir)
-                label_list.remove(label_path)
-
-                # remove corresponding img
-                img_path_png = Path(input_img_dir) / (label_path.stem + '.png')
-                img_path_jpg = Path(input_img_dir) / (label_path.stem + '.jpg')
-                img_path_jpeg = Path(input_img_dir) / (label_path.stem + '.jpeg')
-
-                # PNG
-                if img_path_png in image_list:
-                    # rich.print(f"[bold red]=>corresponding img file: {label_path}, moved.")
-                    if verbose:
-                        LOGGER.warning(f"-> corresponding img file: {img_path_png}, moved.")
-                    shutil.move(str(img_path_png), mv_dir)
-                    
-                # JPG
-                elif img_path_jpg in image_list:
-                    # rich.print(f"[bold red]=>corresponding img file: {label_path}, moved.")
-                    if verbose:
-                        LOGGER.warning(f"-> corresponding img file: {img_path_jpg}, moved.")
-                    shutil.move(str(img_path_jpg), mv_dir)
-                    
-                # JPEG
-                elif img_path_jpeg in image_list:
-                    # rich.print(f"[bold red]=>corresponding img file: {label_path}, moved.")
-                    if verbose:
-                        LOGGER.warning(f"-> corresponding img file: {img_path_jpeg}, moved.")
-                    shutil.move(str(img_path_jpeg), mv_dir)
-                
-
-    # 4. clean up IMG-dir, Label-dir
-    # rich.print(f"> Cleaning-up img-dir * label-dir...")
-    item_list = list(Path(input_img_dir).iterdir())
-    for p in tqdm(item_list, desc=f"Cleaning-up"):
-        if p.suffix in list(img_format) + ['.txt']:
-            continue
-        if verbose:
-            LOGGER.warning(f"Not support format: {p.suffix} --> {p}, moved.")
-        shutil.move(str(p.resolve()), mv_dir)
-
-    # show after check result info
-    # image_list, label_list = load_img_label_list(input_img_dir, input_label_dir, img_format, False)
-    image_list, label_list, video_list = load_from_dir(
-        img_dir=input_img_dir, 
-        label_dir=input_label_dir, 
-        video_dir=None, 
-        verbose=True,
-        title='\nafter',
-        caption='',
-    )
-
-
-    # 如果mv_dir为空，就删掉
-    mv_dir_list = list(Path(mv_dir).iterdir())
-    if len(mv_dir_list) == 0:
-        Path(mv_dir).rmdir()
-
-    # prompt
-    rich.print(f"[bold green]> [Recommand] You should run this command servalal times until it's unchanged!")
-
-
-#---------
-# Usage:
+def increment_path(path, exist_ok=False, sep='', mkdir=False):
+    # Increment file or directory path, i.e. runs/exp --> runs/exp{sep}2, runs/exp{sep}3, ... etc.
+    # Usage:
     '''
     save_dir = increment_path(Path(project) / name, exist_ok=False, sep='-')  # increment run
     save_dir.mkdir(parents=True, exist_ok=True)  # make dir 中间目录存在不报错
     '''
-#---------
-
-def increment_path(path, exist_ok=False, sep='', mkdir=False):
-    # Increment file or directory path, i.e. runs/exp --> runs/exp{sep}2, runs/exp{sep}3, ... etc.
     path = Path(path)  # os-agnostic
     if path.exists() and not exist_ok:
         path, suffix = (path.with_suffix(''), path.suffix) if path.is_file() else (path, '')
         dirs = glob.glob(f"{path}{sep}*")  # similar paths
         matches = [re.search(rf"%s{sep}(\d+)" % path.stem, d) for d in dirs]
         i = [int(m.groups()[0]) for m in matches if m]  # indices
         n = max(i) + 1 if i else 2  # increment number
         path = Path(f"{path}{sep}{n}{suffix}")  # increment path
     if mkdir:
         path.mkdir(parents=True, exist_ok=True)  # make directory
     return path
 
 
-# letter box: but not rect box
-def letterbox(im, new_shape=(640, 640), color=(114, 114, 114)):
-    
-    shape = im.shape[:2]  # current shape [height, width]
-    if isinstance(new_shape, int):
-        new_shape = (new_shape, new_shape)
-
-    # Scale ratio (new / old)
-    r = min(new_shape[0] / shape[0], new_shape[1] / shape[1])
-    # if not scaleup:  # only scale down, do not scale up (for better val mAP)
-    #     r = min(r, 1.0)
-
-    # Compute padding
-    ratio = r, r  # width, height ratios
-    new_unpad = int(round(shape[1] * r)), int(round(shape[0] * r))
-    dw, dh = new_shape[1] - new_unpad[0], new_shape[0] - new_unpad[1]  # wh padding
-
-    # if auto:  # minimum rectangle
-    #     dw, dh = np.mod(dw, stride), np.mod(dh, stride)  # wh padding
-    # if scaleFill:  # stretch
-    #     dw, dh = 0.0, 0.0
-    #     new_unpad = (new_shape[1], new_shape[0])
-    #     ratio = new_shape[1] / shape[1], new_shape[0] / shape[0]  # width, height ratios
-
-    dw /= 2  # divide padding into 2 sides
-    dh /= 2
-
-    if shape[::-1] != new_unpad:  # resize
-        im = cv2.resize(im, new_unpad, interpolation=cv2.INTER_LINEAR)
-    top, bottom = int(round(dh - 0.1)), int(round(dh + 0.1))
-    left, right = int(round(dw - 0.1)), int(round(dw + 0.1))
-    im = cv2.copyMakeBorder(im, top, bottom, left, right, cv2.BORDER_CONSTANT, value=color)  # add border
-    return im, ratio, (dw, dh)
-
-
-
-# get path (img)
-def get_img_path(img_dir, output_txt, img_format, append=True):
-
-    img_dir = Path(img_dir)
-    saveout = Path(output_txt)
-
-    if append:
-        f = open(str(saveout), 'a')
-    else:
-        f = open(str(saveout), 'w')
-
-    image_list = [x for x in Path(img_dir).iterdir() if x.suffix in img_format]
-    LOGGER.info(f"image num: {len(image_list)}")
-
-    for p in image_list:
-        f.write(str(p.resolve()) + '\n')
-    f.close()
-
-
-
-
-
-def resource_info(refresh_time=0.5, display=False):
-
-    # cpu info
-    cpu_count = psutil.cpu_count(logical=False), psutil.cpu_count(logical=True)  # logical, virtual
-    cpu_usage = psutil.cpu_percent(percpu=True, interval=refresh_time)
-    cpu_usage_avg = psutil.cpu_percent(percpu=False, interval=refresh_time)
-    cpu_load_average = psutil.getloadavg()  # sum(cpu_usage) / cpu_count[1]
-
-
-    # mem info
-    mem = psutil.virtual_memory()
-    mem_swap = psutil.swap_memory()
-
-    # create table
-    table = rich.table.Table(title="\n[bold cyan]CPU & MEM INFO", 
-                            box=rich.box.ASCII2, 
-                            show_lines=False, 
-                            caption=f"{datetime.now().strftime('%Y-%m-%d-%H:%M:%S')} (refresh time: {refresh_time})\n",  # Time
-                            caption_justify='center',
-                        )
-
-    # add table column
-    table.add_column(f"CPU\nUSAGE", justify="center", style="cyan", no_wrap=True)
-    # table.add_column(f"CPU\nUSAGE_PER_CORE", justify="center", style="cyan", no_wrap=True)
-    table.add_column("CPU\nCOUNT", justify="center", style="cyan", no_wrap=True)
-    table.add_column(f"CPU\nLOAD_AVERAGE", justify="center", style="cyan", no_wrap=True)
-    table.add_column(f"MEM\nUSAGE", justify="center", style="cyan", no_wrap=True)
-    table.add_column(f"MEM\nTOTAL(GB)", justify="center", style="cyan", no_wrap=True)
-    table.add_column(f"MEM\nUSED(GB)", justify="center", style="cyan", no_wrap=True)
-    table.add_column(f"MEM\nAVAILABLE(GB)", justify="center", style="cyan", no_wrap=True)
-    table.add_column(f"MEM_SWAP\nUSAGE(GB)", justify="center", style="cyan", no_wrap=True)
-    table.add_column(f"MEM_SWAP\nTOTAL(GB)", justify="center", style="cyan", no_wrap=True)
-
-    # add table row
-    table.add_row(
-        f"{cpu_usage_avg}%", 
-        # f"{cpu_usage}", 
-        f"{cpu_count}",
-        f"{cpu_load_average}%", 
-        f"{mem.percent}%", 
-        f"{(mem.total / (1 << 30)):.3f}",   # 2^30, kb=2^10
-        f"{(mem.used / (1 << 30)):.3f}", 
-        f"{(mem.available / (1 << 30)):.3f}", 
-        f"{mem_swap.percent}%", 
-        f"{(mem_swap.total / (1 << 30)):.4}", 
-        end_section=True
-    )
-
-    # display
-    if display is True:
-        CONSOLE.print(table)
-
-    return table
-
-
-def gpu_info(display=False):
-
-
-    # # check if has gpu
-    # if onnxruntime.get_device() != 'GPU':
-    #     LOGGER.error(f"This machine has no GPU device!")
-    #     return
-    # else:
-    #     pynvml.nvmlInit()  # init
-    try:
-        pynvml.nvmlInit()  # init
-    except Exception:
-        LOGGER.error(f"This machine has no GPU device!")
-        return   
-
-    # create table
-    table = rich.table.Table(title="\n[bold cyan]GPU INFO", 
-                            box=rich.box.ASCII2, 
-                            show_lines=False, 
-                            caption=f"{datetime.now().strftime('%Y-%m-%d-%H:%M:%S')}\n",  # Time
-                            caption_justify='center',
-                        )
-
-    # add table column
-    table.add_column("ID", justify="center", style="cyan", no_wrap=True)
-    table.add_column("NAME", justify="center", style="cyan", no_wrap=True)
-    table.add_column("USED", justify="center", style="cyan", no_wrap=True)
-    table.add_column("TOTAL", justify="center", style="cyan", no_wrap=True)
-    table.add_column(f"USAGE", justify="center", style="cyan", no_wrap=True)
-
-
-    pynvml.nvmlInit()  # init
-    for index in range(pynvml.nvmlDeviceGetCount()):   # num_gpu
-        handle = pynvml.nvmlDeviceGetHandleByIndex(index)  # handle
-        mem = pynvml.nvmlDeviceGetMemoryInfo(handle)  # gpu mem
-
-        # add table row
-        table.add_row(
-            f"{index}", 
-            f"{str(pynvml.nvmlDeviceGetName(handle), encoding='utf-8')}",  
-            f"{(mem.used / MB):.3f} MB",  
-            f"{(mem.total / MB):.3f} MB",  
-            f"{(mem.used / MB) / (mem.total / MB) * 100:.4f} %",
-            end_section=True
-        )
-
-    # display
-    if display:
-        CONSOLE.print(table)
-
-    pynvml.nvmlShutdown()  # close
-    return table
-
```

## usls/src/video_tools.py

```diff
@@ -1,329 +1,357 @@
-#!/usr/bin/env python
-# -*- coding:utf-8 -*- 
-
 import cv2
 import os
 import rich
 from tqdm import tqdm
 import argparse
 from pathlib import Path
 import sys
+from omegaconf import OmegaConf, DictConfig
+from datetime import datetime
+
+
+from usls.src.utils import CONSOLE, IMG_FORMAT, VIDEO_FORMAT, LABEL_FORMAT, increment_path
 
 
-#--------------------------------------------
-#       ADD TO PYTHON_PATH
-#--------------------------------------------
-FILE = Path(__file__).resolve()
-ROOT = FILE.parents[0]   # FILE.parent 
-if str(ROOT) not in sys.path:
-    sys.path.append(str(ROOT))  # add ROOT to PATH
-# ROOT = Path(os.path.relpath(ROOT, Path.cwd()))  # abs path => relative
-#--------------------------------------------
 
+def play_and_record(
+        source,
+        delay=1, 
+        flip=None,
+        rotate=None,
+        view=True,
+        fourcc='mp4v',
+        record=False,
+        output_dir=None,
+    ):
+    # video play & record
+
+    # check file
+    if not Path(source).is_file():
+        raise TypeError(f"{source} is not a valid file.")
+        sys.exit()
 
-from utils import increment_path, CONSOLE
-from utils import LOGGER, VIDEO_FORMAT, IMG_FORMAT, letterbox
+    # check format
+    if not Path(source).suffix in VIDEO_FORMAT:
+        raise TypeError(f"{source} is supported video format: {VIDEO_FORMAT}.")
+        sys.exit()
 
+    CONSOLE.log(f"Source: {Path(source).resolve()}")
 
 
+    # flip and rotate
+    if flip:
+        if flip == 'ud':
+            flipCode = 0
+        elif flip == 'lr':
+            flipCode = 1
+        elif flip in('udlr', 'lrud'):
+            flipCode = -1
 
-# video play & record
-def play_and_record(source, delay=1, flip=False):
 
-    # check video path
-    # if Path(source).is_dir():
-    #     LOGGER.error("video path is WRONG!")
-    #     exit(-3)
+    if rotate:
+        if rotate == 90:
+            rotateCode = cv2.ROTATE_90_CLOCKWISE
+        elif rotate == 180:
+            rotateCode = cv2.ROTATE_180
+        elif rotate == 270:
+            rotateCode = cv2.ROTATE_90_COUNTERCLOCKWISE
 
-    # video_cap 
-    videoCapture = cv2.VideoCapture(source)
 
+    videoCapture = cv2.VideoCapture(source)  # video capture
     fps = int(videoCapture.get(cv2.CAP_PROP_FPS))
     w = int(videoCapture.get(cv2.CAP_PROP_FRAME_WIDTH))
     h = int(videoCapture.get(cv2.CAP_PROP_FRAME_HEIGHT))
-    video_size = (w, h)
-    fourcc = cv2.VideoWriter_fourcc(*'mp4v')
-
-    LOGGER.info(f"Video info: width={w}, height={h}, FPS={fps}")
+    # video_size = (w, h)
+    # fourcc_ = cv2.VideoWriter_fourcc(*'mp4v')
+    fourcc_ = cv2.VideoWriter_fourcc(*fourcc)
+    CONSOLE.log(f"Info: width={w}, height={h}, fps={fps}, fourcc={fourcc_}")
 
 
     # record flag
-    do_rec = False
-    LOGGER.info(f"Not recording! Press [r] to record, Press again to stop recording.")
+    do_rec = record
 
-    with CONSOLE.status("[bold cyan]Playing...\n") as status:
+    # rec 
+    if do_rec:
+        CONSOLE.log(f"Rec...")
+        save_dir = increment_path(
+            Path(output_dir) / datetime.now().strftime('%Y-%m-%d-%H-%M-%S'), 
+            exist_ok=False, 
+            sep='-'
+        )  # increment dir
+        save_dir.mkdir(parents=True, exist_ok=True)
+        saveout = save_dir / 'rec.mp4' 
+        video_writer = cv2.VideoWriter(str(saveout), fourcc_, fps, (w, h))  # build video writer
 
-        while True:
-            ret, frame = videoCapture.read()
-            if ret:
-                cv2.imshow('frame', frame)
-                # flip
-                if flip:
-                    frame = cv2.flip(frame, 0)
 
-                # rec
-                if do_rec:
-                    video_writer.write(frame)
+    while True:
+        ret, frame = videoCapture.read()
+        if ret:
 
-                # key detect
-                key = cv2.waitKey(delay)
+            if flip:
+                frame = cv2.flip(frame, flipCode)
+            if rotate:
+                frame = cv2.rotate(frame, rotateCode)
+            if view:
+
+                # rec notice
+                text_rec = "Press R to record"
+                line_thickness = 1
+                fontScale = 0.8
+                w_text, h_text = cv2.getTextSize(text_rec, 0, fontScale=fontScale, thickness=line_thickness)[0]  # text width, height
+                tl = (frame.shape[1]//30, frame.shape[0]//10)
+                br =(frame.shape[1]//30 + w_text, frame.shape[0]//10 - h_text)
+                cv2.rectangle(
+                    frame, 
+                    tl, br, 
+                    (0,0,0), 
+                    -1, 
+                    cv2.LINE_AA
+                )  # filled
+                cv2.putText(
+                    frame, 
+                    text_rec, 
+                    tl, 
+                    cv2.FONT_HERSHEY_SIMPLEX, 
+                    fontScale,
+                    (255,255,255), 
+                    thickness=line_thickness, 
+                    lineType=cv2.LINE_AA
+                )
+                cv2.imshow('frame', frame)
+            
+            # rec
+            if do_rec:
+                video_writer.write(frame)
 
-                # q -> quit
-                if key == ord('q'):
-                    break
+            # key detect
+            key = cv2.waitKey(delay)
 
-                # r -> record
-                if key == ord('r'):
+            # q -> quit
+            if key == ord('q'):
 
-                    # ~                     
-                    do_rec = not do_rec 
+                if do_rec:    
+                    CONSOLE.log(f"Record saved at: {saveout.resolve()}")
 
-                    # rec 
-                    if do_rec:
-                        LOGGER.info(f"Rec...")
+                break
 
-                        dir_name = 'video_record'
-                        sub_name = 'rec'
-                        save_dir = increment_path(Path(dir_name) / sub_name, exist_ok=False, sep='')  # increment run
-                        save_dir.mkdir(parents=True, exist_ok=True)
+            # r -> record
+            if key == ord('R'):
+                do_rec = not do_rec   # ~  
 
-                        video_name = 'rec.mp4'
-                        saveout = save_dir / video_name 
-                        # print(saveout)
-                        video_writer = cv2.VideoWriter(str(saveout), fourcc, fps, video_size)
+                # rec 
+                if do_rec:
+                    CONSOLE.log(f"Rec...")
 
-                    else:
-                        LOGGER.info(f"Done rec. Saved at: {saveout.resolve()}")
+                    save_dir = increment_path(
+                        Path(output_dir) / datetime.now().strftime('%Y-%m-%d-%H-%M-%S'), 
+                        exist_ok=False, 
+                        sep='-'
+                    )  # increment dir
+                    save_dir.mkdir(parents=True, exist_ok=True)
+                    saveout = save_dir / 'rec.mp4' 
+                    video_writer = cv2.VideoWriter(str(saveout), fourcc_, fps, (w, h))
 
-            else:
-                # print('can not read frame!')
-                break
+                else:
+                    CONSOLE.log(f"Record saved at: {saveout.resolve()}")
+        else:
+            break
 
 
     # release cap & video cap
     videoCapture.release()
-    cv2.destroyAllWindows()
-
-    LOGGER.info(f"Done.")
+    if view:
+        cv2.destroyAllWindows()
 
 
 
-# video -> images
-def video_to_images(source,                             # 0: cam
-                    output="V2I",      # save dir
-                    x=20,         # every 20 frame  to save
-                    view=False,
-                    flip=False,
-                    img_fmt=".jpg",
-                    verbose=True
-                    ):
+def v2is(
+        source,      
+        output_dir,  
+        x=20,         # every 20 frame  to save
+        flip=None,
+        rotate=None,
+        img_fmt=".jpg",
+        view=False,
+        verbose=True,
+    ):
+    # video clipping
 
-    # check video path
+    # check file
     if not Path(source).is_file():
-        LOGGER.error("video path is WRONG!")
-        exit(-3)
+        raise TypeError(f"{source} is not a valid file.")
+        sys.exit()
+
+    # check format
+    if not Path(source).suffix in VIDEO_FORMAT:
+        raise TypeError(f"{source} is supported video format: {VIDEO_FORMAT}.")
+        sys.exit()
+
+
+    # image dir name
+    image_dir = Path(source).stem
+
+    # flip and rotate
+    if flip:
+        if flip == 'ud':
+            flipCode = 0
+            image_dir += '-flipud'
+        elif flip == 'lr':
+            flipCode = 1
+            image_dir += '-fliplr'
+        elif flip in('udlr', 'lrud'):
+            flipCode = -1
+            image_dir += '-flipudlr'
+
+
+    if rotate:
+        if rotate == 90:
+            rotateCode = cv2.ROTATE_90_CLOCKWISE
+            image_dir += '-rotate90'
+        elif rotate == 180:
+            rotateCode = cv2.ROTATE_180
+            image_dir += '-rotate180'
+        elif rotate == 270:
+            rotateCode = cv2.ROTATE_90_COUNTERCLOCKWISE
+            image_dir += '-rotate270'
+
+
 
     # frame count
     idx = 0 
 
     # save_dir 
-    save_dir = increment_path(Path(output), exist_ok=False, sep='_')  # increment run
-    save_dir.mkdir(parents=True, exist_ok=True)  # make dir 中间目录存在不报错
+    save_dir = increment_path(
+        Path(output_dir) / image_dir,
+        exist_ok=False, 
+        sep='-'
+    )  # increment run
+    save_dir.mkdir(parents=True, exist_ok=True)  # make dir
 
 
     # load video
     cap = cv2.VideoCapture(str(source))
 
-    # read video
-    # if verbose:
-    #     rich.print(f"> [cyan]Spliting...")   
     
     while True:
         ret, frame = cap.read()
         if ret == True:
-
-            # flip frame
-            if flip:
-                frame = cv2.flip(frame, 0)   
-
-            # rotate
-            # frame = cv2.rotate(frame, cv2.ROTATE_90_CLOCKWISE)
-            
-            #frame = cv2.rotate(frame, cv2.ROTATE_90_CLOCKWISE)
-
-            # show video 
-            if view:       
+            if flip:    # flip frame
+                frame = cv2.flip(frame, flipCode)   
+            if rotate:      # rotate
+                frame = cv2.rotate(frame, rotateCode)
+            if view:  # show video      
                 cv2.imshow('video', frame)
 
-            # video to img
+            # clipping
             if idx % x == 0:                
-                img_saveout = save_dir / (Path(source).stem + '_' + str(idx) + img_fmt)
+                # img_saveout = save_dir / (Path(source).stem + '_' + str(idx) + img_fmt)
+                img_saveout = save_dir / (str(idx) + img_fmt)
                 cv2.imwrite(str(img_saveout), frame)
             
-            # frame index counting
-            idx += 1
-
-            # 'q' to quit
-            if cv2.waitKey(1) & 0xFF == ord('q'):
+            idx += 1    # frame index counting
+            if cv2.waitKey(1) & 0xFF == ord('q'):   # 'q' to quit
                 break
         else:
-            # LOGGER.error(f"Not capture video frame! Please check the video path.")
             break
 
-
-    # release cap
-    cap.release()
-
-    # close opencv windows if opened.
-    if view:
+    
+    cap.release()  # release cap
+    if view:  # close opencv windows if opened.
         cv2.destroyAllWindows()
 
 
+    # success info
     if verbose:
-        # successful info
-        LOGGER.info(f"\nImages saved at: {save_dir.resolve()}")
+        CONSOLE.log(f"Saved at: {save_dir.resolve()}")
+
+
 
 
+def vs2is(
+        directory,      
+        output_dir,  
+        x=20,       
+        flip=None,
+        rotate=None,
+        img_fmt=".jpg",
+        view=False,
+    ):
+    # videos -> images
 
-# batch videos -> images
-def videos_to_images(
-                    input_dir,
-                    output_dir='',
-                    x=30,
-                    view=False,
-                    flip=False,
-                    img_fmt=".jpg",
-                    ):
 
     # video list
-    video_list = [x for x in Path(input_dir).iterdir() if x.suffix in VIDEO_FORMAT]
-    # rich.print(f"[italic magenta]==>Videos to be split:[/italic magenta]\n{video_list}\n\n")
-    # rich.print(f"> Video spliting list:")
-    rich.print([str(x.resolve()) for x in video_list])
+    video_list = [x for x in Path(directory).glob('**/*') if x.suffix in VIDEO_FORMAT]
+    # CONSOLE.log(f"{len(video_list)} videos found.")
+
 
     # if empty dir, stop
     if len(video_list) == 0:
-        LOGGER.warning(f"Empty video directory")
-        exit(-3)
+        CONSOLE.log(f"No video found.")
+        sys.exit()
 
 
     # split videos one by one
     for video in tqdm(video_list, desc=f"videos -> images"):
-        with CONSOLE.status("[bold cyan]spliting...\n") as status:
-            save_out = Path(input_dir) / video.stem if not output_dir else Path(output_dir) / video.stem
-            video_to_images(
-                source=video,           
-                output=save_out,      # save dir
-                x=x,
-                view=view,
-                flip=flip,
-                img_fmt=img_fmt,
-                verbose=False
-            )
-
-    # successful info
-    LOGGER.info(f"Saved at: {Path(output_dir).resolve()}")
-
+        v2is(
+            source=video,           
+            output_dir=output_dir,      # save dir
+            x=x,
+            view=view,
+            flip=flip,
+            img_fmt=img_fmt,
+            verbose=False,
+        )
+
+    # success info
+    CONSOLE.log(f"Saved at: {Path(output_dir).resolve()}")
 
 
-# images -> video
-# 所有图片应当是统一尺寸
-# todo: 当有错误图片的时候，无法转换，新增错误处理
-def images_to_video(source, 
-                    size,
-                    last4=30, 
-                    fps=30, 
-                    ):
-    
-    # load images
-    # IMG_FORMAT = [".jpg", ".png", ".jpeg", ".bmp"]  
-    images_list = [x.resolve() for x in Path(source).iterdir() if x.suffix in IMG_FORMAT]
-    LOGGER.info(f"{len(images_list)} found.")
-
-
-    # save out dir
-    dir_name = 'is2v'
-    sub_name = 'video'
-    save_dir = increment_path(Path(dir_name) / sub_name, exist_ok=False, sep='')  # increment run
-    save_dir.mkdir(parents=True, exist_ok=True)
-
-    video_name = 'imgs_2_video.mp4'
-    saveout = save_dir / video_name 
-    fourcc = cv2.VideoWriter_fourcc(*'mp4v')  # mp4
-    video_writer = cv2.VideoWriter(str(saveout), fourcc, fps, size)
-
-    # key detect
-    key = cv2.waitKey(1)
-
-    # loop
-    for img in tqdm(images_list):
-        frame = cv2.imread(str(img))  
-        # resize
-        # todo: letter_box()
-        # frame = cv2.resize(frame, size)
-        frame = letterbox(frame, size)[0]
-
-        for idx in range(int(last4)):
-            video_writer.write(frame)
-
-
-    # done 
-    LOGGER.info(f"Done. Video saved at: {saveout.resolve()}") 
-    video_writer.release()
-
-
-
-
-# options
-def parse_opt():
-    parser = argparse.ArgumentParser()
-    parser.add_argument('--input', type=str, default='', help='img dir path(s)')
-    parser.add_argument('--output', type=str, default='v2is', help='output dir')
-    parser.add_argument('--format', type=str, default='.jpg', help='img suffix')
-    parser.add_argument('--frame', type=float, default=30, help='N frame')
-    parser.add_argument('--view', action='store_true',help='imshow')
-    parser.add_argument('--flip', action='store_true',help='Flip frame')
-    parser.add_argument('--fps', default=30, help='Flip frame')
-    parser.add_argument('--mode', default='play', help='Flip frame')
-
-    opt = parser.parse_args()
-    rich.print(opt, end="\n\n")
-    return opt
-
 
+# -----------------------------------------------------------------------------
+#  run
+# -----------------------------------------------------------------------------
+
+def run_v2is(args: DictConfig):
+
+    with CONSOLE.status("[bold green]Video Clipping...", spinner='line') as status:
+        v2is(
+            source=args.source,      
+            output_dir=args.output_dir,  
+            x=args.frame,       
+            flip=args.flip,
+            rotate=args.rotate,
+            img_fmt=args.fmt_img,
+            view=args.view,
+        )
+
+
+def run_vs2is(args: DictConfig):
+
+    # with CONSOLE.status("[bold green]Video Clipping...", spinner='line') as status:
+    vs2is(
+        directory=args.dir,      
+        output_dir=args.output_dir,  
+        x=args.frame,       
+        flip=args.flip,
+        rotate=args.rotate,
+        img_fmt=args.fmt_img,
+        view=args.view,
+    )
+
+
+def run_play(args: DictConfig):
+    with CONSOLE.status("[green]Playing...\n") as status:
+
+        play_and_record(
+            source=args.source,
+            delay=args.delay, 
+            flip=args.flip,
+            rotate=args.rotate,
+            view=not args.no_view,
+            fourcc=args.fourcc,
+            record=args.rec,
+            output_dir=args.output_dir,
+        )
 
 
 
-if __name__ == '__main__':
-
-    opt = parse_opt()
-
-    if opt.mode == 'v2is':
-        # test 1
-        video_to_images(source=opt.input,                             # 0: cam
-                        output=opt.output,      # save dir
-                        x=opt.frame,
-                        view=opt.view,
-                        flip=opt.flip,
-                        )   
-    elif opt.mode == 'vs2is':
-        # test 2
-        videos_to_images(
-                        input_dir=opt.input,
-                        output_dir=opt.output,
-                        x=opt.frame,
-                        view=opt.view,
-                        flip=opt.flip,
-                        img_fmt=opt.format
-                        )
-    elif opt.mode == 'play':
-        # # test 3
-        play_and_record(source=opt.input, delay=1, flip=False)
-
-    elif opt.mode == 'is2v':
-        # test 4
-        images_to_video(source=opt.input, 
-                        last4=opt.fps, 
-                        fps=opt.fps, 
-                        size=(2000, 2000),
-                        )
```

### encoding

```diff
@@ -1 +1 @@
-utf-8
+us-ascii
```

## Comparing `usls-0.1.0.dist-info/LICENSE` & `usls-0.2.1.dist-info/LICENSE`

 * *Files identical despite different names*

## Comparing `usls-0.1.0.dist-info/METADATA` & `usls-0.2.1.dist-info/METADATA`

 * *Files 24% similar despite different names*

```diff
@@ -1,27 +1,25 @@
 Metadata-Version: 2.1
 Name: usls
-Version: 0.1.0
+Version: 0.2.1
 Summary: Useless CV toolkits
 Home-page: https://github.com/jamjamjon/usls
 Author: jamjamjon
 License: GPL-3.0
-Requires-Python: >=3.7
+Requires-Python: >=3.9
 Description-Content-Type: text/markdown
 License-File: LICENSE
-Requires-Dist: BaiduSpider
-Requires-Dist: hydra-core
+Requires-Dist: baiduspider
 Requires-Dist: numpy
 Requires-Dist: omegaconf
 Requires-Dist: opencv-python
 Requires-Dist: packaging
 Requires-Dist: Pillow
-Requires-Dist: psutil
-Requires-Dist: Pygments
-Requires-Dist: pynvml
 Requires-Dist: PyYAML
 Requires-Dist: requests
 Requires-Dist: rich
 Requires-Dist: tqdm
+Requires-Dist: photohash
+Requires-Dist: loguru
 
 # usls
-uselesss
+useless
```

## Comparing `usls-0.1.0.dist-info/RECORD` & `usls-0.2.1.dist-info/RECORD`

 * *Files 23% similar despite different names*

```diff
@@ -1,20 +1,23 @@
-usls/__init__.py,sha256=O9yEv94vgq8qbgdXFHGNfl01CA6T8Gv_-aWU14If8Xg,236
-usls/cli.py,sha256=DTEd67B04LRnSaDmHF5Wb1-cGvsy0TmoFtzzTz9jJBw,1879
-usls/run.py,sha256=aPAeXdXS9KfelPpjpeXY_qEHe2tPHAKnSGnd-cjjYVY,13002
-usls/src/__init__.py,sha256=sOvJIS48PlCb5VxgHWJURfVCWHToAUvk3dy0DPAN2FI,345
+usls/__init__.py,sha256=MvMdXXuE1o8ecodvP1_ClMaOpSy0asz5HlW4dp-tYdc,171
+usls/cli.py,sha256=VZce68IJqqpJDz7jTXxda1a3KVKOopeDTYUjCSnT8S8,11563
+usls/run.py,sha256=bSl-x3wSxrGIh9I2QwoTESi_e2WyI8QN9ruE_7bl1Zk,2629
+usls/src/__init__.py,sha256=taQDSBFDUilwiGM8wY4BJ1rZL90B8Ahvc-UpHy5d5pE,309
 usls/src/class_modify.py,sha256=MVwj18Z47GV67EfLv77wEKMfRLT2DgOmckQPFQQkU2I,2171
-usls/src/deduplicate.py,sha256=IjLlnx9w080xfllIxoWYYLHqU-c0VSf-sIixIN7cXao,1598
-usls/src/dir_combine.py,sha256=XNXKt3s8fk3ApVQluPkt4ReRRfwCTWHAkyZJ61mPMvE,2537
+usls/src/cleanup.py,sha256=ABQiSHOxgLS9zr4-0vCbPe1hrJAeEfatxLEgBpjlU60,6028
+usls/src/deduplicate.py,sha256=7Uaq4QScnOVPVMWRZiG1eBXorg9oF6SWjJklsL6rc_w,5530
+usls/src/dir_combine.py,sha256=xatoOY54X8oMTvH3HJflgTfJdIBOG3gdTJyLOEQEmVc,1739
+usls/src/info.py,sha256=ZCzsaR0DNPBLNnqwibcxkS4aWprGBKaZy9-pwVgdL68,3945
 usls/src/label_combine.py,sha256=T99nvA4fcHt94cCV9zZVPJvmgj_Lus-5H3lowCbp9So,3204
 usls/src/labelling_cls.py,sha256=yFW_zeBBFr_HS6fu5mqUpPq9-z0F_txAhUGpg-RchRQ,18138
-usls/src/labelling_det.py,sha256=2O72FnhHBVvrE6-6LTZWlDOup1cUV4LBCjfKC3FflNI,41064
+usls/src/labelling_det.py,sha256=VnoxsLxSl3DokJcKx6VNp4Fa9uUXYVbeFRkJ-9OsnJE,39435
 usls/src/labelling_det_2.py,sha256=jfiW3F7NifoV64QylkRi5yYmeWJW6HMUkJchEzCjAJ4,40829
-usls/src/spider.py,sha256=ecqEz3Qer94U9Gms7IWLo9tlPLa9GIbMbPWy_G9h2jM,3299
-usls/src/utils.py,sha256=eK9RARNe7KEE2OTah1_qnfUhTHFJOfbNJ0uTRyYqx5I,24160
-usls/src/video_tools.py,sha256=zJKFXhKWH5lpFOvUyQpALYwnSyZMBw9V1kTaKzAzTW4,9416
-usls-0.1.0.dist-info/LICENSE,sha256=OXLcl0T2SZ8Pmy2_dmlvKuetivmyPd5m1q-Gyd-zaYY,35149
-usls-0.1.0.dist-info/METADATA,sha256=dt0WxmZdOFweFbXn5R4dzFxDNKh2lTtv6wf0RzCykJ0,588
-usls-0.1.0.dist-info/WHEEL,sha256=2wepM1nk4DS4eFpYrW1TTqPcoGNfHhhO_i5m4cOimbo,92
-usls-0.1.0.dist-info/entry_points.txt,sha256=NtT7OjVpekraB5xlzXzTbTQ9q8VOKMUrByrtciZMJms,34
-usls-0.1.0.dist-info/top_level.txt,sha256=oS7b-J2DgqOuJIQaKnSyirCC_Rt6yeQCLkbNqh2H_DM,5
-usls-0.1.0.dist-info/RECORD,,
+usls/src/rename.py,sha256=IxH2LsZEfitXtHEd7PiSlNx4JyLsblJQuIGOOGLyvu4,2555
+usls/src/spider.py,sha256=g70JjlPX5H2qOjMrmdHspaW9lki9kVIprEBtV49lD8M,3470
+usls/src/utils.py,sha256=JoP0kWsWOX7m1k8MZ0PgSCG4lIkAGNzDsLQAiHi1Brg,5906
+usls/src/video_tools.py,sha256=hR2UdXOWdZfh732YHyUCHnHBuR5dSQ7Hu2M3LYmMaZY,9386
+usls-0.2.1.dist-info/LICENSE,sha256=OXLcl0T2SZ8Pmy2_dmlvKuetivmyPd5m1q-Gyd-zaYY,35149
+usls-0.2.1.dist-info/METADATA,sha256=nh2pJ2tegX8rbzlfrPYrRTp3u8bAJPhQDfwwm91Yb8A,540
+usls-0.2.1.dist-info/WHEEL,sha256=2wepM1nk4DS4eFpYrW1TTqPcoGNfHhhO_i5m4cOimbo,92
+usls-0.2.1.dist-info/entry_points.txt,sha256=NtT7OjVpekraB5xlzXzTbTQ9q8VOKMUrByrtciZMJms,34
+usls-0.2.1.dist-info/top_level.txt,sha256=oS7b-J2DgqOuJIQaKnSyirCC_Rt6yeQCLkbNqh2H_DM,5
+usls-0.2.1.dist-info/RECORD,,
```

